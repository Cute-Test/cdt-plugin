//!ITDA_SimpleInt
//@A1.cpp
typedef int a;
/*$*/a/*$$*/ i;
//=
typedef int a;
int i;

//!IDTA_SimplePointerAlias
//@A1.cpp
using PI=int (*);
/*$*/PI/*$$*/ pi;
//=
using PI=int (*);
int* pi;

//!IDTA_SimplePointerConstAlias
//@A1.cpp
using PI=int const (*);
/*$*/PI/*$$*/ pi;
//=
using PI=int const (*);
const int* pi;

//!IDTA_ConstPointerWihtPointerDeclaratorAlias
//@A1.cpp
using PI=int const (*);
/*$*/PI/*$$*/ * const pi;
//=
using PI=int const (*);
const int** const pi;

//!IDTA_VolatilePointerConstRefWihtPointerDeclaratorAlias
//@A1.cpp
using PI=int const (*);
/*$*/PI/*$$*/ volatile * const & pi;
//=
using PI=int const (*);
const int* volatile * const & pi;

//!IDTA_StaticConstReference
//@A1.cpp
using PI=int const (*);
static /*$*/PI/*$$*/ * const & pi = nullptr;
//=
using PI=int const (*);
static const int** const & pi = nullptr;

//!IDTA_FunctionReturnUsage
//@A1.cpp
using PI=int const (*);
inline /*$*/PI/*$$*/ foo();
//=
using PI=int const (*);
inline const int* foo();

//!IDTA_MultipleDeclarators
//@A1.cpp
using PI=int const (*);
extern /*$*/PI/*$$*/ * const &pi = nullptr, pa { };
//=
using PI=int const (*);
extern const int ** const &pi = nullptr, *pa { };

//!IDTA_InFunctionParameter
//@A1.cpp
using PI=int const (*);
void foo(/*$*/PI/*$$*/ * const &pi);
//=
using PI=int const (*);
void foo(const int** const & pi);

//!IDTA_CombineCVInSpecifier
//@A1.cpp
using PV=int const;
extern /*$*/PV/*$$*/ volatile &pv;
//=
using PV=int const;
extern const volatile int& pv;

//!IDTA_CombineCVInDeclarator
//@A1.cpp
using PV=int const *;
extern /*$*/PV/*$$*/ volatile &pv;
//=
using PV=int const *;
extern const int* volatile & pv;

//!IDTA_AliasInCastExpression
//@A1.cpp
using PV=int const *;
auto x = reinterpret_cast</*$*/PV/*$$*/>(1);
//=
using PV=int const *;
auto x = reinterpret_cast<const int*>(1);

//!IDTA_AliasInCastExpressionWithDeclarator
//@A1.cpp
using PV=int const *;
auto x = reinterpret_cast</*$*/PV/*$$*/*>(1);
//=
using PV=int const *;
auto x = reinterpret_cast<const int**>(1);

//!IDTA_MemberFunctions
//@A1.cpp
struct X{
	typedef int const *PCI;
	virtual /*$*/PCI/*$$*/ const *foo() const &;
	friend PCI bar(){ return PCI{};}
};
//=
struct X{
	typedef int const *PCI;
	const virtual int* const * foo() const &;
	friend PCI bar(){ return PCI{};}
};
//!IDTA_FriendFunctionDefinition
//@A1.cpp
struct X{
	typedef int const *PCI;
	virtual PCI const *foo() const &;
	friend /*$*/PCI/*$$*/ const & bar() {
		return PCI { };
	}
};
//=
struct X{
	typedef int const *PCI;
	virtual PCI const *foo() const &;
	const friend int* const & bar() {
		return PCI { };
	}
};
//!IDTA_FunctionDefinition
//@A1.cpp
typedef void * bar;
/*$*/bar/*$$*/ foo() {
	return nullptr;
}
//=
typedef void * bar;
void* foo() {
	return nullptr;
}

//!IDTA_ArrayInAlias
//@A1.cpp
typedef void * bar[10];
/*$*/bar/*$$*/ kneipe;
//=
typedef void * bar[10];
void* kneipe[10];

//!IDTA_AliasInArray
//@A1.cpp
typedef void * bar[10];
/*$*/bar/*$$*/ kneipe[2];
//=
typedef void * bar[10];
void* kneipe[2][10];

//!IDTA_AliasInArrayOfPointersKeepsParentheses
//@A1.cpp
typedef void * bar[10];
/*$*/bar/*$$*/ * const kneipe[2];
// array with 2 elemens with are const pointers to array with 10 elements which are void *

//=
typedef void * bar[10];
void* (* const kneipe[2])[10];
// array with 2 elemens with are const pointers to array with 10 elements which are void *

//!IDTA_ArrayOfFunctionPointersInAnArray
//@A1.cpp
typedef void (* const bar[10])(int);
/*$*/bar/*$$*/ const kneipe[2];
// array with 2 elemens with are const of array with 10 elements which are function pointers
//=
typedef void (* const bar[10])(int);
void (* const kneipe[2][10])(int);
// array with 2 elemens with are const of array with 10 elements which are function pointers
//!IDTA_TypeidInTemplateParameter
//@A1.cpp
template <typename T> struct X{};
using B=int const *;
static X</*$*/B/*$$*/> x;
//=
template <typename T> struct X{};
using B=int const *;
static X<const int*> x;

//!IDTA_TypeidInTemplateParameterWithAbstractDeclarator
//@A1.cpp
template <typename T> struct X{};
using B=int const *;
static X</*$*/B/*$$*/ const &> x;
//=
template <typename T> struct X{};
using B=int const *;
static X<const int* const &> x;

//!IDTA_NameFromNestedScope
//@A1.cpp
#include <vector.hpp>
using siter=std::string::iterator;
/*$*/siter/*$$*/ it;
//=
#include <vector.hpp>
using siter=std::string::iterator;
std::string::iterator it;

//!IDTA_NameFromNestedScopeWithTemplateID
//@A1.cpp
#include <vector.hpp>
using iter=std::vector<std::string>::iterator;
/*$*/iter/*$$*/ it;
//=
#include <vector.hpp>
using iter=std::vector<std::string>::iterator;
std::vector<std::string>::iterator it;

//!IDTA_NameFromNestedScopeWithTemplateIDAndDeclarator
//@A1.cpp
#include <vector.hpp>
using iterref=std::vector<std::string>::iterator const &;
/*$*/iterref/*$$*/ it;
//=
#include <vector.hpp>
using iterref=std::vector<std::string>::iterator const &;
const std::vector<std::string>::iterator& it;

//!IDTA_NameFromNestedScopeWithAliasInScope
//@A1.cpp
#include <vector.hpp>
namespace alias {
using siter=std::string::iterator;
}
alias::/*$*/siter/*$$*/ it;
//=
#include <vector.hpp>
namespace alias {
using siter=std::string::iterator;
}
std::string::iterator it;

//!IDTA_NameFromSameNestedScopeAsAlias
//@A1.cpp
namespace alias {
struct X{typedef int I;};
using type=X::I;
}
alias::/*$*/type/*$$*/ *it;
//=
namespace alias {
struct X{typedef int I;};
using type=X::I;
}
alias::X::I* it;

//!IDTA_NameFromNestedScopeWithAliasInScope1
//@A1.cpp
#include <vector.hpp>
namespace alias {
using std::string;
using siter=string::iterator;
}
alias::/*$*/siter/*$$*/ it;
//=
#include <vector.hpp>
namespace alias {
using std::string;
using siter=string::iterator;
}
alias::string::iterator it;

//!IDTA_NameFromNestedScopeWithTemplate
//@A1.cpp
#include <vector.hpp>
namespace alias {
using std::vector;
using vec=vector<int>;
}
alias::/*$*/vec/*$$*/ v;
//=
#include <vector.hpp>
namespace alias {
using std::vector;
using vec=vector<int>;
}
alias::vector<int> v;

//!IDTA_NameFromNestedScopeWithTemplateFromOutside
//@A1.cpp
#include <vector.hpp>
namespace alias {
using vec=std::vector<int>;
}
alias::/*$*/vec/*$$*/ v;
//=
#include <vector.hpp>
namespace alias {
using vec=std::vector<int>;
}
std::vector<int> v;

//!IDTA_NameFromNestedScopeWithTemplateSubtype
//@A1.cpp
#include <vector.hpp>
namespace alias {
using std::vector;
using siter=vector<int>::iterator;
}
alias::/*$*/siter/*$$*/ it;
//=
#include <vector.hpp>
namespace alias {
using std::vector;
using siter=vector<int>::iterator;
}
alias::vector<int>::iterator it;

//!IDTA_NameFromNestedScopeWithTemplateSubtypeFromOutside
//@A1.cpp
#include <vector.hpp>
namespace alias {
using siter=std::vector<int>::iterator;
}
alias::/*$*/siter/*$$*/ it;
//=
#include <vector.hpp>
namespace alias {
using siter=std::vector<int>::iterator;
}
std::vector<int>::iterator it;

