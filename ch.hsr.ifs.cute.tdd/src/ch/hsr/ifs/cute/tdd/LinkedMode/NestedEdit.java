/*******************************************************************************
 * Copyright (c) 2011, IFS Institute for Software, HSR Rapperswil,
 * Switzerland, http://ifs.hsr.ch
 * 
 * Permission to use, copy, and/or distribute this software for any
 * purpose without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *******************************************************************************/
package ch.hsr.ifs.cute.tdd.LinkedMode;

import org.eclipse.ltk.core.refactoring.Change;
import org.eclipse.ltk.core.refactoring.CompositeChange;
import org.eclipse.ltk.core.refactoring.TextChange;
import org.eclipse.text.edits.InsertEdit;
import org.eclipse.text.edits.ReplaceEdit;
import org.eclipse.text.edits.TextEdit;

/**
 * Alternative for TextEdit which does not offer a getText() method. Extracts the essential edit out of a change. Usable for analyzing changes
 * generated by refactorings. Supports only Insert- and ReplaceEdits.
 */
public class NestedEdit {

	private static final String EMPTY_String = ""; //$NON-NLS-1$
	private TextEdit source;

	public NestedEdit(Change change) {
		source = new InsertEdit(0, EMPTY_String);
		try {
			CompositeChange cc = (CompositeChange) change;
			TextChange edit = (TextChange) cc.getChildren()[0];
			InsertEdit findInsertEdit = findInsertEdit(edit.getEdit());
			if (findInsertEdit != null) {
				source = findInsertEdit;
			}
		} catch (ClassCastException e1) {
			throw new ChangeNotSupportedException(Messages.NestedEdit_0, e1);
		} catch (ArrayIndexOutOfBoundsException e2) {
			throw new ChangeNotSupportedException(Messages.NestedEdit_1, e2);
		}
	}

	private InsertEdit findInsertEdit(TextEdit edit) {
		if (edit instanceof InsertEdit) {
			return (InsertEdit) edit;
		}

		for (TextEdit childEdit : edit.getChildren()) {
			InsertEdit childInsertEdit = findInsertEdit(childEdit);
			if (childInsertEdit != null) {
				return childInsertEdit;
			}
		}
		return null;
	}

	public String getText() {
		if (source instanceof InsertEdit) {
			return ((InsertEdit) source).getText();
		} else if (source instanceof ReplaceEdit) {
			return ((ReplaceEdit) source).getText();
		}
		return EMPTY_String;
	}

	/**
	 * @return position inside the document where the change starts
	 */
	public int getOffset() {
		return source.getOffset();
	}

	/**
	 * @return greater zero if the edit replaces some text
	 * @return zero if the edit only inserts text at a certain position
	 */
	public int getLength() {
		return source.getLength();
	}

	/**
	 * @return length of the text that will be inserted by this edit
	 */
	public int getTextLength() {
		return getText().length();
	}

	/**
	 * @return absolute index to the affected document
	 */
	public int absoluteIndexOf(String text) {
		return getOffset() + getText().indexOf(text);
	}
}
