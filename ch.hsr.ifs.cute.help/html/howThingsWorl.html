<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1" />
<link rel="stylesheet" type="text/css" href="../help.css" />
<title>How things work</title>
</head>

<body>
<h2>How things work</h2>
<p>I tried to create a simple orthogonal and thus easy to extend and
adapt testing framework that stays easy to use. Exploiting C++ library
features that are modern (boost) and will be part of the future standard
(std::tr1) I could avoid some complexity for CUTE's users.</p>

<h2>Cute Test</h2>
<p>The core class representing tests uses boost::function, which
will be std::tr1::function, when compilers support this designated
extension, to store test functions. So any parameterless function or
functor can be a test. In addition each cute::test has a name, so that
it can be easier identified. That name is either given during
construction or derived from a functor's typeid. The GNU g++ compiler
requires to demangle that name given by the type_info object, where VC++
already provides a human readable type_info::name() result.</p>
<pre class='code'> 
struct test{
    test(VoidFunctor const &amp;t, std::string name = 
             demangle(typeid(VoidFunctor).name()))
    :theTest(t),name_(name){}
 
    void operator()()const{ theTest(); }
    std::string name()const{ return name_;}
 
    static std::string demangle(char const *name);
private:
    boost::function&lt;void()&gt; theTest;
    std::string name_;
};
</pre>
<p>As you can see, there is no need to inherit from class test. The
only thing I do not yet like, is the static function demangle, that
needs to be implemented per compiler. I haven't found a better place for
it in the framework yet.</p>
<p>For simple functions, or if you want to name your tests
differently from the functor's type, you can use the following CUTE()
macro.</p>
<pre class='code'> 
#define CUTE(name) cute::test((&amp;name),#name)
</pre>
<p><em>This was one of the gotchas with more modern C++
compilers (VS and g++ &gt;4, because the early version of the macro
didn't use the address-of operator for the function name thus resulting
in the inability to automatically instantiate cute::test's template
constructor. Using C for more than 20 years I thought using a function
name will give you a function pointer and that the &amp; would be
superfluous, which is no longer in C++.</em></p>
<p>The using of a template constructor allows you to use any kind of
functor, that can be stored in a boost::function&lt;void()&gt;, that
means a functor that doesn't take parameters. With boost::bind() you are
able to construct those, even from functions, functors or member
functions with parameters as shown below.</p>
<h2>Sweet Suites</h2>
<p>Running a single test with cute::runner is not very interesting -
you might call that function directly and check results. But having a
larger collection of test cases and running them after every compile and
on a build server after every check in, is what makes unit testing so
powerful. So there is a need for running many tests at once.</p>
<p>But in contrast to other unit testing frameworks (including
JUnit) I refrained from applying the Composite Design Pattern [ GoF ]
for implementing the container for these many test cases your project
requires. I love Composite and it is handy in many situations for tree
structures, but it comes at a price of strong coupling by inheritance
and lower cohesion in the base class, because of the need to support the
composite class' interface. The simplest solution I came up with is just
using a std::vector&lt;cute::test&gt; as my representation for test
suites. Instead of a hierarchy of suites, you just run a sequence of
tests. When the tests run, the hierarchy doesn't play a role. You still
can arrange your many tests in separate suites, but before you run them,
you either concatenate the vectors or you run the suites in your main
function separately through the runner.</p>
<p>For those of you who really want your test suites to be tests,
CUTE provides a suite_test functor that will take a suite and run it
through its call operator. But if any test of the suite in such a
suite_test fails, the remaining tests won't be run.</p>
<p>To make it easy to fill your suite with your tests CUTE provides
an overloaded operator+= that will append a test object to a suite. This
idea is blatantly stolen from boost::assign, which I didn't use, because
to my knowledge it didn't make it to std::tr1 (yet?).</p>
<p>So this is all it takes to have test suites:</p>
<pre class='code'> 
typedef std::vector&lt;test&gt; suite;
suite &amp;operator+=(suite &amp;left, suite const &amp;right);
suite &amp;operator+=(suite &amp;left, test const &amp;right);
</pre>
<h2>Assertions and Failures</h2>
<p>A unit testing framework wouldn't be complete without a means to
actually check something in a convenient way. One principle of testing
is to fail fast, so any failed test assertion will abort the current
test and signal that failure to the top-level runner. You might already
have guessed that throwing an exception is the corresponding mechanism.
Since we want to know later on, where that test failed, I introduced an
exception class test_failure that takes the filename and line number of
the source position. Java can do that automatically for exceptions, but
as C++ programmers we have to carry that information ourselves and we
have to rely on the preprocessor to actually know where we are in the
code. Another std::string allows sending additional information from the
test programmer to the debugger of a failing test.</p>
<p>This is how cute.h looks without the necessary #include guards
and #include of &lt;string&gt;:</p>
<pre class='code'> 
namespace cute{
struct test_failure {
	std::string reason;
	std::string filename;
	int lineno;
	test_failure(std::string const &amp;r,char const *f, int line)
	:reason(r),filename(f),lineno(line)
	{ 	}
	std::string what() const ;
};
}
</pre>
<p>For actually writing test assertions I provided macros that will
throw, if a test fails. I deliberately used lower case spelling for
these macros to make them easier to use.</p>
<pre class='code'> 
#define ASSERTM(msg,cond) if (!(cond)) \
            throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)
#define FAIL() ASSERTM("fail()",false)
#define FAILM(msg) ASSERTM(msg,false)
</pre>
<p>This is all for you to get started. However, some convenience is
popular in testing frameworks. But convenience often tends to be
over-engineered and I am not yet sure if the convenience functionality I
provided is yet simple enough. Therefore I ask for your feedback on how
to make things simpler or encouragement that it is already simple
enough.</p>
<h2>Equality - Overengineered?</h2>
<p>Testing two values for equality is may be one of the most popular
tests. Therefore, all testing frameworks provide a means to test for
equality. JUnit, for example, provides a complete amount of overloaded
equality tests. C++ templates can do that as well with less code. For
more complex data types, such as strings, it might be hard to see the
difference between two values given, when they are simply printed in the
error message.</p>
<pre class='code'> 
void anothertest(){
	ASSERT_EQUAL(42,lifeTheUniverseAndEverything);
}
</pre>
<p>One means to implement ASSERT_EQUAL would be to just #define it
to map to ASSERT((expected)==(actual)). However, from my personal
experience of C++ unit testing since 1998, this is too simplistic in
cases where the comparison fails. Especially for strings or domain
objects seeing the difference between two values is often important for
correcting a programming mistake. In my former life, we had custom error
messages for a failed string compare to spot the difference easily.
Therefore, CUTE provides a template implementation of assert_equal that
again is called by a macro, to enable file position gathering.</p>
<p>I speculated (may be wrongly) it would be useful to be able to
specify your own mechanism to create the message if two values differ,
which also is implemented as a to-be-overloaded template function.</p>
<pre class='code'> 
template &lt;typename EXPECTED, typename ACTUAL&gt;
std::string diff_values(EXPECTED const &amp;expected
			,ACTUAL const &amp; actual){
// construct a simple message...
	std::ostringstream os;
	os &lt;&lt; "(" &lt;&lt; expected&lt;&lt;","&lt;&lt;actual&lt;&lt;")";
	return os.str();
}
// special overloaded cases for strings
std::string diff_values(std::string const &amp;,std::string const &amp;);
std::string diff_values(char const * const &amp;exp,std::string const &amp;act);
 
template &lt;typename EXPECTED, typename ACTUAL&gt;
void assert_equal(EXPECTED const &amp;expected ,ACTUAL const &amp;actual
                  ,char const *msg,char const *file,int line) {
	if (expected == actual) return;
	throw test_failure(msg + diff_values(expected,actual),file,line);
}
#define ASSERT_EQUALM(msg,expected,actual) \
    cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) \
    ASSERT_EQUALM(#expected " expected but was " #actual, expected,actual)
</pre>
<p>I encourage readers to criticize this design to help me to come
up with something simpler.</p>
<h2>Listening Customization</h2>
<p>You've already seen, that the runner class template can be
specialized by providing a listener. The runner class is an inverted
application of the Template Method Design Pattern GoF. Instead of
implementing the methods called dynamically in a subclass, you provide a
template parameter that acts as a base class to the class runner, which
holds the Template Methods runit() and operator().</p>
<pre class='code'> 
template &lt;typename Listener=null_listener&gt;
struct runner : Listener{
    runner():Listener(){}
    runner(Listener &amp;s):Listener(s){}
    bool operator()(test const &amp;t){
        return runit(t);
    }
    bool operator()(suite const &amp;s,char const *info=""){ 
        Listener::begin(s,info);
        bool result=true;
        for(suite::const_iterator it=s.begin();it != s.end();++it){
            result = this-&gt;runit(*it) &amp;&amp; result;
        }
        Listener::end(s,info);
        return result;
    }
private:
    bool runit(test const &amp;t){
        try {
            Listener::start(t);
            t();
            Listener::success(t,"OK");
            return true;
        } catch (test_failure const &amp;e){
            Listener::failure(t,e);
        } catch(...) {
            Listener::error(t,"unknown exception thrown");
        }
        return false;
    }
};
</pre>
<p>If you look back to runner::runit, you will recognize that if any
reasonable exception is thrown, it would be hard to diagnose, what the
reason for an error is. Therefore, I included catch clauses for
std::exception, string and char pointers to get information required for
diagnosis. The demangling is required for GNU g++ to get a
human-readable information from the exception's class name.</p>
<pre class='code'> 
        } catch (std::exception const &amp;exc){
            Listener::error(t,test::demangle(exc.what()).c_str());
        } catch (std::string &amp;s){
            Listener::error(t,s.c_str());
        } catch (char const *&amp;cs) {
            Listener::error(t,cs);
</pre>
<p>Again I ask you for feedback if doing so seems over-engineered.
Are you throwing strings as error indicators?</p>
<p>As you can see, there are a bunch of methods delegated to the
base class given as runner's template parameter (begin, end, start,
success, failure, error). The default template parameter null_listener
applies the Null Object Design Pattern and provides the concept all
fitting Listener base classes.</p>
<pre class='code'> 
struct null_listener{ // defines Contract of runner parameter
	void begin(suite const &amp;s, char const *info){}
	void end(suite const &amp;s, char const *info){}
	void start(test const &amp;t){}
	void success(test const &amp;t,char const *msg){}
	void failure(test const &amp;t,test_failure const &amp;e){}
	void error(test const &amp;t,char const *what){}
};
</pre>
<p>So whenever you need to collect the test results or you want to
have a nice GUI showing progress with the tests, you can create your own
specific listener.</p>
<p>Again you can employ an inverted version of a GoF Design Pattern,
to stack listeners. This is application of an inverted Decorator using
C++ templates, for example to count the number of tests regarding their
category:</p>
<pre class='code'> 
template &lt;typename Listener=null_listener&gt;
struct counting_listener:Listener{
    counting_listener()
    :Listener()
    ,numberOfTests(0),successfulTests(0)
    ,failedTests(0),errors(0),numberOfSuites(0){}
 
    counting_listener(Listener const &amp;s)
    :Listener(s)
    ,numberOfTests(0),successfulTests(0)
    ,failedTests(0),errors(0),numberOfSuites(0){}
 
    void begin(suite const &amp;s, char const *info){
        ++numberOfSuites;
        Listener::begin(s,info);
    }
    void start(test const &amp;t){
        ++numberOfTests;
        Listener::start(t);
    }
    void success(test const &amp;t,char const *msg){
        ++successfulTests;
	Listener::success(t,msg);
    }
    void failure(test const &amp;t,test_failure const &amp;e){
        ++failedTests;
        Listener::failure(t,e);
    }
    void error(test const &amp;t,char const *what){
        ++errors;
        Listener::error(t,what);
    }
    int numberOfTests;
    int successfulTests;
    int failedTests;
    int errors;
    int numberOfSuites;
};
</pre>
<p>From the above schema, you can derive your own stackable listener
classes, e.g. one showing the progress of running the tests and their
results in a GUI. If you do so, share your solution.</p>
<h2>Test Extensions</h2>
<p>With the idea of allowing all non-parameter Functors to be
eligible as tests, it is relatively simple to provide test-wrappers for
different kind of functionality.</p>
<h3>Exception Testing</h3>
<p>Good practice of unit testing is also to check if things go wrong
as intended.</p>
<p>To embed a piece of code (an expression or function call) that
should throw an specific exception type you can use the macro</p>
<pre class='code'> 
ASSERT_THROWS(code,exception_type);
</pre>
<p>within your test function, like for example:</p>
<pre class='code'> 
void test_that_something_throws() {
    ASSERT_TRHOWS(should_throw_std_exception(),std::exception);
}
</pre>
<p>This test will fail, if <code>should_throw_std_exception()</code>
is not throwing a std::exception value. You can use function calls or
simple expressions as a macro parameter. You might need parenthesis to
disambiguiate, if your piece of code contains commas, i.e., in a
parameter list.</p>
<p>If you want to expect a specific exception from a test functor,
the code to do that can easily be canned for reuse in a template and
with CUTE it is activated by a macro call like:</p>
<pre class='code'> 
    suite s;
    s += CUTE_EXPECT(functor_that_throws(),std::exception);
</pre>
<p>The implementation of that mechanism is as you have expected:</p>
<pre class='code'> 
template &lt;typename EXCEPTION&gt;
struct cute_expect{
	test theTest;
	std::string filename;
	int lineno;
	cute_expect(test const &amp;t,char const *file,int line)
	:theTest(t), filename(file), lineno(line){}
	void operator()(){
		try{
			theTest();
			throw test_failure(what(),filename.c_str(),lineno);
		} catch(EXCEPTION &amp;e) {
		}
	}
	std::string what() const{
		return theTest.name() + " expecting " 
		       + test::demangle(typeid(EXCEPTION).name());
	}
};
#define CUTE_EXPECT(tt,exc) \
    cute::test(cute::cute_expect&lt;exc&gt;(tt,__FILE__,__LINE__),tt.name())
</pre>
<p>No need to implement the try-catch again by hand for testing
error conditions. What is missing, is ability to expect a runtime error
recognized by the operating system such as an invalid memory access.
Those are usually signalled instead of thrown as a nice C++ exception.</p>
<p>With a similar wrapper you can implement a class for repeatedly
running a test. There isn't even a template required.</p>
<h3>Member functions as tests</h3>
<p>Having boost::bind() at your disposal, it is easy to construct a
functor object from a class and its member function. Again this is
canned in a macro that can be used like</p>
<pre class='code'> 
CUTE_MEMFUN(testobject,TestClass,test1);
CUTE_SMEMFUN(TestClass,test2);
CUTE_CONTEXT_MEMFUN(contextobject,TestClass,test3);
</pre>
<p>The first version uses object testobject, an instance of
TestClass, as the target for the member function test1. The second
version, creates a new instance of TestClass to then call its member
function test2 when the test is executed. The last macro provides a
means to pass an additional object, to TestClass' constructor, when it
is incarnated. The idea of incarnating the test object and thus have its
constructor and destructor run as part of the test comes from Kevlin
Henney and is implemented in Paul Grenyer's testing framework Aeryn.</p>
<p>The macro CUTE_MEMFUN delegates its work to a template function
as follows:</p>
<pre class='code'> 
template &lt;typename TestClass&gt;
test makeMemberFunctionTest(TestClass &amp;t,void (TestClass::*fun)(),char const *name){
    return test(boost::bind(fun,boost::ref(t)),test::demangle(typeid(TestClass).name())+"::"+name);
}
#define CUTE_MEMFUN(testobject,TestClass,MemberFunctionName) \
    cute::makeMemberFunctionTest(testobject,\
        &amp;TestClass::MemberFunctionName, #MemberFunctionName)
</pre>
<p>The template function makeMemberFunctionTest employs boost::bind
to create a functor object that will call the member function fun on
object t, when called. Again we can employ C++ reflection using typeid
to derive part of the test object's name. We need to derive the member
function name again using the preprocessor with a macro. To allow to use
also const member functions, the template function comes in two
incarnations, one using a reference as shown and the other one using a
const reference for the testing object.</p>

<h3>Test Object Incarnation</h3>
<p>I will spare you all details, but give you the mechanism of
object incarnation and then calling a member function for the case,
where you can supply a context object.</p>
<pre class='code'> 
template &lt;typename TestClass,typename MemFun, typename Context&gt;
struct incarnate_for_member_function_with_context_object {
	MemFun memfun;
	Context context;
	incarnate_for_member_function_with_context_object(MemFun f,Context c)
	:memfun(f),context(c){}
	void operator()(){
		TestClass t(context);
		(t.*memfun)();
	}
};
template &lt;typename TestClass, typename MemFun, typename Context&gt;
test makeMemberFunctionTestWithContext(Context c,MemFun fun,char const *name){
	return test(incarnate_for_member_function_with_context_object&lt;TestClass,MemFun,Context&gt;(fun,c),test::demangle(typeid(TestClass).name())+"::"+name);
}
</pre>
<p>This will allow you to use test classes with a constructor
setting up a test fixture and a destructor clearing it again. So there
is no longer a need for writing Java like setUp() and tearDown()
methods.</p>
</body>
</html>
