<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">

<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>CUTE - Theory of Operation and Goals - C++ Unit Testing Easier</title>
<meta name="description" content="Redmine" />
<meta name="keywords" content="issue,bug,tracker" />
<link rel='shortcut icon' href='http://cute-test.com/favicon.ico?1293099743' />
<link href="../../../themes/cute/stylesheets/applicationade1.css?1295341309" media="all" rel="stylesheet" type="text/css" />

<script src="http://cute-test.com/javascripts/prototype.js?1251746896" type="text/javascript"></script>
<script src="http://cute-test.com/javascripts/effects.js?1254993814" type="text/javascript"></script>
<script src="http://cute-test.com/javascripts/dragdrop.js?1254993814" type="text/javascript"></script>
<script src="http://cute-test.com/javascripts/controls.js?1254993814" type="text/javascript"></script>
<script src="http://cute-test.com/javascripts/application.js?1293099743" type="text/javascript"></script>
<link href="../../../stylesheets/jstoolbara45c.css?1293099743" media="screen" rel="stylesheet" type="text/css" />
<!--[if IE]>
    <style type="text/css">
      * html body{ width: expression( document.documentElement.clientWidth < 900 ? '900px' : '100%' ); }
      body {behavior: url(/stylesheets/csshover.htc?1293099743);}
    </style>
<![endif]-->

<!-- page specific tags -->

  <link href="../../../stylesheets/scma45c.css?1293099743" media="screen" rel="stylesheet" type="text/css" />
</head>
<body class="theme-Cute controller-wiki action-index">
<div id="wrapper">
<div id="wrapper2">
<div id="top-menu">
    <div id="account">
        <ul><li><a href="http://cute-test.com/login" class="login">Sign in</a></li>
<li><a href="http://cute-test.com/account/register" class="register">Register</a></li></ul>    </div>
    
    <ul><li><a href="http://cute-test.com/" class="home">Home</a></li>
<li><a href="http://cute-test.com/projects" class="projects">Projects</a></li>
<li><a href="http://www.redmine.org/guide" class="help">Help</a></li></ul></div>
      
<div id="header">
    <div id="quick-search">
        <form action="http://cute-test.com/search/index/cute" method="get">
        <input name="wiki_pages" type="hidden" value="1" />
        <a href="http://cute-test.com/search/index/cute" accesskey="4">Search</a>:
        <input accesskey="f" class="small" id="q" name="q" size="20" type="text" />
        </form>
        
    </div>
    
    <h1>CUTE</h1>
    
    
    <div id="main-menu">
        <ul><li><a href="http://cute-test.com/projects/cute" class="overview">Overview</a></li>
<li><a href="http://cute-test.com/projects/cute/activity" class="activity">Activity</a></li>
<li><a href="http://cute-test.com/projects/cute/news" class="news">News</a></li>
<li><a href="http://cute-test.com/projects/cute/wiki" class="wiki selected">Wiki</a></li>
<li><a href="http://cute-test.com/projects/cute/files" class="files">Files</a></li></ul>
    </div>
    
</div>

<div class="" id="main">
    <div id="sidebar">        
        
    <h1 id="Cute">Cute<a href="#Cute" class="wiki-anchor">&para;</a></h1>


	<p><strong><a href="http://cute-test.com/projects/cute/wiki">Main</a></strong></p>


	<p><strong><a href="User_Guide.html" class="wiki-page">User Guide</a></strong></p>


	<p><strong><a href="http://www.ifs.hsr.ch/" class="external">Contact</a></strong></p>

<h3>Wiki</h3>

<a href="http://cute-test.com/projects/cute/wiki">Start page</a><br />
<a href="Page_index.html">Index by title</a><br />
<a href="Date_index.html">Index by date</a><br />


        
    </div>
    
    <div id="content">
				
        <div class="contextual">


<span id="watcher"></span>






<a href="Theory_of_Operation_and_Goals/history.html" class="icon icon-history">History</a>
</div>

<p class="breadcrumb"><a href="User_Guide.html">User Guide</a> &#187; </p>



<div class="wiki">
  <h1 id="Theory-of-Operation-and-Goals-of-CUTE">Theory of Operation and Goals of CUTE<a href="#Theory-of-Operation-and-Goals-of-CUTE" class="wiki-anchor">&para;</a></h1>


	<p>CUTE leverages modern C++ libraries and features to make writing C++ unit tests easier. For example, one disadvantage of <a href="http://sourceforge.net/apps/mediawiki/cppunit/index.php?title=Main_Page" class="external">CppUnit</a> is that you have to write a subclass in order to have your own test case. This is a lot of programmer overhead, especially when you want to start small.</p>


	<p>CUTE stands for C++ Unit Testing Easier. This article was first published by Peter Sommerlad in <a href="http://accu.org/index.php/journals/1349" class="external">ACCU Overload Journal #75</a>. It is maintained here in the wiki with updates to match the current version of CUTE.</p>


	<p>I was inspired by Kevlin Henney's Java testing framework called JUTLAND (Java Unit Testing: Light, Adaptable 'n' Discreet), and the corresponding presentation he gave at JAOO 2005. In addition, I wondered if I could come up with a design that is similarly orthogonal, easily extendable and also much simpler to use than current C++ unit testing approaches.</p>


	<p>Here you will learn how to use CUTE in your projects and also some of the more modern C++ coding techniques employed for its implementation. I also ask you to give feedback to help me further simplify and improve CUTE.</p>


	<h2 id="My-Problems-with-CppUnit">My Problems with CppUnit<a href="#My-Problems-with-CppUnit" class="wiki-anchor">&para;</a></h2>


	<p>Inheritance is a very strong coupling between classes. Requiring a test case class to inherit from a CppUnit framework class couples both closely together. The <a href="http://cppunit.sourceforge.net/doc/lastest/cppunit_cookbook.html" class="external">CppUnit Cookbook</a> tutorial lists at least 6 classes you must deal with in order to get things up and running. You even have to decide if you want to inherit from TestCase or TestFixture for even the simplest test case. I do not want to go into more details, but this is how I want to write tests:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="pp">#include</span> <span class="ic">&quot;cute.h&quot;</span> 
<span class="no">2</span> <span class="pt">int</span> lifeTheUniverseAndEverything = <span class="i">42</span>;
<span class="no">3</span> 
<span class="no">4</span> <span class="di">void</span> mysimpletest(){
<span class="no">5</span>     ASSERT(lifeTheUniverseAndEverything == <span class="i">6</span>*<span class="i">7</span>);
<span class="no">6</span> }
</span></code></pre><br />That's it. A simple test is a simple void function. Done. Well, almost done.

	<p>In addition, CppUnit originated in the days of non-standard C++ compilers, when the more modern features of the language were just not broadly available. From a modern perspective, this limits its design.</p>


	<p>Today, all relevant compilers (with the exception of the still in use MSVC6) are able to compile most of standard C++ and the proposed std::tr1 libraries from Boost.</p>


	<h2 id="Running-a-Single-Test">Running a Single Test<a href="#Running-a-Single-Test" class="wiki-anchor">&para;</a></h2>


	<p>Since we lack some of the reflection mechanisms available in Java, testing with CUTE requires its own main function. For simple cases this is straightforward. As with CppUnit you instantiate a runner object and pass it your test. The simplest possible way to produce some output is:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="pp">#include</span> <span class="ic">&lt;iostream&gt;</span>
<span class="no"> 2</span> <span class="pp">#include</span> <span class="ic">&quot;cute_runner.h&quot;</span> 
<span class="no"> 3</span> <span class="pt">int</span> main(){
<span class="no"> 4</span>     <span class="di">using</span> <span class="r">namespace</span> std;
<span class="no"> 5</span> 
<span class="no"> 6</span>     <span class="r">if</span> (cute::runner&lt;&gt;()(mysimpletest)){
<span class="no"> 7</span>         cout &lt;&lt; <span class="s"><span class="dl">&quot;</span><span class="k">OK</span><span class="dl">&quot;</span></span> &lt;&lt; endl;
<span class="no"> 8</span>     } <span class="r">else</span> {
<span class="no"> 9</span>         cout &lt;&lt; <span class="s"><span class="dl">&quot;</span><span class="k">failed</span><span class="dl">&quot;</span></span> &lt;&lt; endl;
<span class="no"><strong>10</strong></span>     }   
<span class="no">11</span> }
</span></code></pre>

	<p>This may not yet be very impressive, but it is simple. Reporting test outcome is important, so CUTE provides a means to configure the runner with a listener. You may have wondered why cute::runner has template brackets. This is where you specify the listener class:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="pt">int</span> main(){
<span class="no">2</span>     <span class="di">using</span> <span class="r">namespace</span> std;
<span class="no">3</span> 
<span class="no">4</span>     cute::runner&lt;cute::ostream_listener&gt;()(mysimpletest);
<span class="no">5</span> }
</span></code></pre>

	<p>This test succeeds and outputs,</p>


<pre><code>
"void () () OK" 
</code></pre>

	<p>From the above test result, we know only that a void function without any arguments ran successfully. This shows the C++ introspection limitation, which only provides type information, not function names. But the preprocessor can help us. We make our test cuter by applying the macro <acronym title="">CUTE</acronym>:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> cute::runner&lt;cute::ostream_listener&gt;()(
<span class="no">2</span>     CUTE(mysimpletest));
</span></code></pre>

	<p>This test succeeds, it produces the terse output mysimpletest OK. However, if we make the test fail by setting the variable to lifeTheUniverseAndEverything to 41 instead of 42, we get,</p>


<pre><code>
../simpletest.cpp:6: testcase failed: lifeTheUniverseAndEverything == 6*7 in mysimpletest
</code></pre>

	<p>This failure message contains everything we need to find the origin of the failure, plus some context help to hint at the problem. You probably already guessed that the preprocessor macro <acronym title="">ASSERT</acronym> from cute.h contains the magic that collects this interesting information.</p>


	<p>For a better integration into Visual Studio and Eclipse IDEs, CDT CUTE now provides yet another listener, cute::ide_listener. This listener allows navigation from failure messages to their source, and even provides a red/green bar UI within Eclipse CDT.</p>


	<h2 id="How-Things-Work">How Things Work<a href="#How-Things-Work" class="wiki-anchor">&para;</a></h2>


	<p>I tried to create a simple, orthogonal and thus easy to extend and adapt testing framework that stays easy to use. I avoided some complexity for users of CUTE by exploiting modern C++ library features in the Boost library that will be part of the future std::tr1 standard.</p>


	<p>Note that all classes presented below are in namespace cute, which is omitted for the sake of brevity.</p>


	<h2 id="Cute-Test">Cute Test<a href="#Cute-Test" class="wiki-anchor">&para;</a></h2>


	<p>The core class stores test functions using boost::function. When TR1 support is added to compilers, this will be renamed std::tr1::function. With boost::function, any parameterless function or functor can be a test. In addition, each cute::test has a name for easier identification. That name is given either during construction or derived from a functor's typeid. The GNU g++ compiler requires that you demangle the name given by the type_info object, while VC++ provides a human readable type_info::name() result directly.</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="r">struct</span> test{
<span class="no"> 2</span>     test(VoidFunctor <span class="di">const</span> &#38;t, std::<span class="pt">string</span> name = 
<span class="no"> 3</span>              demangle(<span class="r">typeid</span>(VoidFunctor).name()))
<span class="no"> 4</span>     :theTest(t),name_(name){}
<span class="no"> 5</span> 
<span class="no"> 6</span>     <span class="di">void</span> <span class="di">operator</span>()()<span class="di">const</span>{ theTest(); }
<span class="no"> 7</span>     std::<span class="pt">string</span> name()<span class="di">const</span>{ <span class="r">return</span> name_;}
<span class="no"> 8</span> 
<span class="no"> 9</span>     <span class="di">static</span> std::<span class="pt">string</span> demangle(<span class="pt">char</span> <span class="di">const</span> *name);
<span class="no"><strong>10</strong></span> <span class="di">private</span>:
<span class="no">11</span>     boost::function&lt;<span class="di">void</span>()&gt; theTest;
<span class="no">12</span>     std::<span class="pt">string</span> name_;
<span class="no">13</span> };
</span></code></pre>

	<p>As you can see, there is no need to inherit from class test. The only thing I do not like about this is that the static function demangle must be implemented on a per compiler basis. I have not yet found a better place for it in the framework.</p>


	<p>For simple functions, or when you want to name your tests differently from the functor's type, you can use the <acronym title="">CUTE</acronym> macro:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="pp">#define</span> CUTE(name) cute::test((&#38;name),<span class="pp">#name</span>)
</span></code></pre>

	<p>This was one of the problems with more modern C++ compilers (VS and g++ > 4), because the early version of the macro didn't use the address-of operator for the function name. This resulted in the inability to automatically instantiate the cute::test template constructor. Having used C for more than 20 years, I thought that using a function name would give you a function pointer and that the &#38; would be superfluous, which is no longer the case in C++.</p>


	<p>Using a template constructor allows you to use any kind of functor that can be stored in a boost::function&lt;void()&gt;, but this means that the functor can take no parameters. To construct with functions, functors or member functions with parameters, use boost::bind() as shown below.</p>


	<h2 id="Sweet-Suites">Sweet Suites<a href="#Sweet-Suites" class="wiki-anchor">&para;</a></h2>


	<p>Running a single test with cute::runner is not very interestingâ€”you might as well just call that function directly and check the results. The power of unit testing is realized when you have a larger collection of test cases that run after every compile and on a build server after every check-in. Thus there is a need for running many tests at once.</p>


	<p>In contrast to other unit testing frameworks (including JUnit) I refrained from applying the Composite design pattern [GoF] for implementing the test case container. I love Composite and it is handy in many situations for tree structures, but it comes at the price of strong coupling by inheritance and lower cohesion in the base class, because of the need to support the composite class' interface. The simplest solution I came up with is to simply represent the test suite as a std::vector&lt;cute::test&gt;. Instead of a hierarchy of suites, you just run a sequence of tests. When the tests run, the hierarchy play no role. You still can arrange your many tests into separate suites, but before you run them, you either concatenate the vectors or you run the suites individually in your main() function using the runner.</p>


	<p>Tests can be added to the suite using vector::push_back(), but to make it really easy to fill your suite with tests, CUTE also provides an overloaded operator+= that will append a test object to a suite:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="r">typedef</span> std::vector&lt;test&gt; suite;
<span class="no">2</span> suite &#38;<span class="di">operator</span>+=(suite &#38;left, suite <span class="di">const</span> &#38;right);
<span class="no">3</span> suite &#38;<span class="di">operator</span>+=(suite &#38;left, test <span class="di">const</span> &#38;right);
</span></code></pre>

	<p>This idea is blatantly stolen from boost::assign, which is not used in CUTE because as far as I know, boost::assign will not appear in std::tr1.</p>


	<p>So this is all it takes to build a test suite:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> suite s;
<span class="no">2</span> s += TestFunctorA();
<span class="no">3</span> s += CUTE(testFunctionB());
<span class="no">4</span> <span class="c">// and so on    ...</span>
</span></code></pre>

	<p>If you really want to organize your test as a sequence of test suites, CUTE provides a suite_test functor that will take a test suite and run it through its call operator. However, if any test in a suite_test fails, the remaining tests will not be run.</p>


	<p>CUTE's Eclipse plug-in eases the construction of test suites by providing automatic code generation and adjustment for registering test functions in suites. You can have stand-alone CUTE executables for a single suite, or test multiple suites, each in a separate library project.</p>


	<h2 id="Assertions-and-Failures">Assertions and Failures<a href="#Assertions-and-Failures" class="wiki-anchor">&para;</a></h2>


	<p>A unit testing framework would not be complete without a way to actually check something in a convenient way. One principle of testing is to fail fast, so any failed test assertion will abort the current test and signal the failure to the top-level runner. You might have already guessed that this is done by throwing an exception. Later on, we will want to know where that test failed, so I introduced an exception class test_failure that takes the source file name and line number in the source file. Java does this automatically for exceptions, but as C++ programmers we must obtain and store this information ourselves. We rely on the preprocessor to actually know where we are in the code. Another std::string allows sending additional information from the test programmer to the debugger of a failing test.</p>


	<p>This is how cute.h looks without the necessary #include guards and #include &lt;string&gt;:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="r">namespace</span> cute{
<span class="no"> 2</span> <span class="r">struct</span> test_failure {
<span class="no"> 3</span>         std::<span class="pt">string</span> reason;
<span class="no"> 4</span>         std::<span class="pt">string</span> filename;
<span class="no"> 5</span>         <span class="pt">int</span> lineno;
<span class="no"> 6</span>         test_failure(std::<span class="pt">string</span> <span class="di">const</span> &#38;r,<span class="pt">char</span> <span class="di">const</span> *f, <span class="pt">int</span> line)
<span class="no"> 7</span>         :reason(r),filename(f),lineno(line)
<span class="no"> 8</span>         {       }
<span class="no"> 9</span>         std::<span class="pt">string</span> what() <span class="di">const</span> ;
<span class="no"><strong>10</strong></span> };
<span class="no">11</span> }
</span></code></pre>

	<p>For actually writing test assertions, I provided macros that will throw if a test fails:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="pp">#define</span> ASSERTM(msg,cond) <span class="r">if</span> (!(cond)) \
<span class="no">2</span>             <span class="r">throw</span> cute::test_failure((msg),__FILE__,__LINE__)
<span class="no">3</span> <span class="pp">#define</span> ASSERT(cond) ASSERTM(<span class="pp">#cond</span>,cond)
<span class="no">4</span> <span class="pp">#define</span> FAIL() ASSERTM(<span class="s"><span class="dl">&quot;</span><span class="k">fail()</span><span class="dl">&quot;</span></span>,<span class="pc">false</span>)
<span class="no">5</span> <span class="pp">#define</span> FAILM(msg) ASSERTM(msg,<span class="pc">false</span>)
</span></code></pre>

	<p>This is all you need to get started. However, some convenience is popular in testing frameworks. Unfortunately, convenience often tends to be over-engineered and I am not yet sure if the convenience functionality I provided is yet simple enough. Therefore I ask for your feedback on how to make things simpler or confirmation that it is already simple enough.</p>


	<h2 id="Testing-for-Equality">Testing for Equality<a href="#Testing-for-Equality" class="wiki-anchor">&para;</a></h2>


	<p>Testing two values for equality is probably the most popular test. Therefore, all testing frameworks provide a means to test for equality. JUnit, for example, provides a complete set of overloaded equality tests. C++ templates can do that as well with less code. For more complex data types, such as strings, it can be difficult to see the difference between two values, when they are simply printed in the error message.</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="di">void</span> anothertest(){
<span class="no">2</span>         ASSERT_EQUAL(<span class="i">42</span>,lifeTheUniverseAndEverything);
<span class="no">3</span> }
</span></code></pre>

	<p>One means to implement ASSERT_EQUAL would be to just #define it to map to <acronym title="(expected">ASSERT</acronym>==(actual)). However, from my personal experience of C++ unit testing since 1998, this gives too little information when the comparison fails. This is especially true for strings or domain objects, where seeing the two unequal values is often essential for correcting the programming mistake. In my former life, we had custom error messages for a failed string compare that allowed us to spot the difference easily. Therefore, CUTE provides a template implementation of ASSERT_EQUAL This is of course called by a macro to enable file position reporting.</p>


	<p>I speculated (perhaps wrongly) that it would be useful to specify your own mechanism to create the message if two values differ, which also is implemented as a to-be-overloaded template function.</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="r">template</span> &lt;<span class="r">typename</span> EXPECTED, <span class="r">typename</span> ACTUAL&gt;
<span class="no"> 2</span> std::<span class="pt">string</span> diff_values(EXPECTED <span class="di">const</span> &#38;expected
<span class="no"> 3</span>                         ,ACTUAL <span class="di">const</span> &#38; actual){
<span class="no"> 4</span> <span class="c">// construct a simple message...</span>
<span class="no"> 5</span>         std::ostringstream os;
<span class="no"> 6</span>         os &lt;&lt; <span class="s"><span class="dl">&quot;</span><span class="k">(</span><span class="dl">&quot;</span></span> &lt;&lt; expected&lt;&lt;<span class="s"><span class="dl">&quot;</span><span class="k">,</span><span class="dl">&quot;</span></span>&lt;&lt;actual&lt;&lt;<span class="s"><span class="dl">&quot;</span><span class="k">)</span><span class="dl">&quot;</span></span>;
<span class="no"> 7</span>         <span class="r">return</span> os.str();
<span class="no"> 8</span> }
<span class="no"> 9</span> <span class="c">// special overloaded cases for strings</span>
<span class="no"><strong>10</strong></span> std::<span class="pt">string</span> diff_values(std::<span class="pt">string</span> <span class="di">const</span> &#38;,std::<span class="pt">string</span> <span class="di">const</span> &#38;);
<span class="no">11</span> std::<span class="pt">string</span> diff_values(<span class="pt">char</span> <span class="di">const</span> * <span class="di">const</span> &#38;exp,std::<span class="pt">string</span> <span class="di">const</span> &#38;act);
<span class="no">12</span> 
<span class="no">13</span> <span class="r">template</span> &lt;<span class="r">typename</span> EXPECTED, <span class="r">typename</span> ACTUAL&gt;
<span class="no">14</span> <span class="di">void</span> assert_equal(EXPECTED <span class="di">const</span> &#38;expected ,ACTUAL <span class="di">const</span> &#38;actual
<span class="no">15</span>                   ,<span class="pt">char</span> <span class="di">const</span> *msg,<span class="pt">char</span> <span class="di">const</span> *file,<span class="pt">int</span> line) {
<span class="no">16</span>         <span class="r">if</span> (expected == actual) <span class="r">return</span>;
<span class="no">17</span>         <span class="r">throw</span> test_failure(msg + diff_values(expected,actual),file,line);
<span class="no">18</span> }
<span class="no">19</span> <span class="pp">#define</span> ASSERT_EQUALM(msg,expected,actual) \
<span class="no"><strong>20</strong></span>     cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
<span class="no">21</span> <span class="pp">#define</span> ASSERT_EQUAL(expected,actual) \
<span class="no">22</span>     ASSERT_EQUALM(<span class="pp">#expected</span> <span class="s"><span class="dl">&quot;</span><span class="k"> expected but was </span><span class="dl">&quot;</span></span> <span class="pp">#actual</span>, expected,actual)
</span></code></pre>

	<p>As of version 1.5 CUTE allows all kinds of type to be compared by ASSERT_EQUAL. While earlier versions allowed only types where operator<<(ostream &#38;,TYPE) was defined, some template meta-programming tricks now allow also other types, as long as operator==(expected,actual) is defined and delivers a bool compatible result. For integer types, meta-programming ensures that no signed-unsigned comparison warning is issued anymore (this requires boost version >= 1.34, so cygwin users watch out). Comparing two floating point values without specifying a delta, automatically selects a delta that masks the least significant decimal digit, based on the size of expected. Floating point comparison subtracts actual and expected and sees if the absolute value of the difference is less than delta, by using std::abs()</p>


	<h2 id="Exception-Testing">Exception Testing<a href="#Exception-Testing" class="wiki-anchor">&para;</a></h2>


	<p>Another good unit testing practice is to verify that things go wrong as intended.</p>


	<p>To embed a piece of code (an expression, or anyhting that can be passed as a macro parameter) that should throw an specific exception type, you can use the macro</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> ASSERT_THROWS(code,exception_type);
<span class="no">2</span> within your test function. For example:
<span class="no">3</span> 
<span class="no">4</span> <span class="di">void</span> test_that_something_throws() {
<span class="no">5</span>     ASSERT_THROWS(should_throw_std_exception(),std::exception);
<span class="no">6</span> }
</span></code></pre>

	<p>This test will fail if should_throw_std_exception() does not throw an exception of type std::exception. Any other exception will lead to an error, in contrast to failure.</p>


	<p>There is no need to implement the try-catch again by hand to test error conditions. What is missing is the ability to expect a runtime error recognized by the operating system such as an invalid memory access. Those are usually signaled instead of thrown as a nice C++ exception.</p>


	<p>You might need parenthesis around the code in the macro parameter to disambiguate commas, particularly commas in a parameter list.</p>


	<p>As of CUTE 1.5 the macro CUTE_EXPECT(testfunctor,excpetion) is no longer supported, ASSERT_THROWS is simpler and seems to be sufficient.</p>


	<h2 id="Listening-Customization">Listening Customization<a href="#Listening-Customization" class="wiki-anchor">&para;</a></h2>


	<p>You have already seen that the runner class template can be specialized by providing a listener. The runner class is an inverted application of the Template Method design pattern [GoF]. Instead of implementing the methods called dynamically in a subclass, you provide a template parameter that acts as a base class to the class runner, which holds the template methods runit() and operator().</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="r">template</span> &lt;<span class="r">typename</span> Listener=null_listener&gt;
<span class="no"> 2</span> <span class="r">struct</span> runner : Listener{
<span class="no"> 3</span>     runner():Listener(){}
<span class="no"> 4</span>     runner(Listener &#38;s):Listener(s){}
<span class="no"> 5</span>     <span class="pt">bool</span> <span class="di">operator</span>()(test <span class="di">const</span> &#38;t){
<span class="no"> 6</span>         <span class="r">return</span> runit(t);
<span class="no"> 7</span>     }
<span class="no"> 8</span>     <span class="pt">bool</span> <span class="di">operator</span>()(suite <span class="di">const</span> &#38;s,<span class="pt">char</span> <span class="di">const</span> *info=<span class="s"><span class="dl">&quot;</span><span class="dl">&quot;</span></span>){ 
<span class="no"> 9</span>         Listener::begin(s,info);
<span class="no"><strong>10</strong></span>         <span class="pt">bool</span> result=<span class="pc">true</span>;
<span class="no">11</span>         <span class="r">for</span>(suite::const_iterator it=s.begin();it != s.end();++it){
<span class="no">12</span>             result = <span class="lv">this</span>-&gt;runit(*it) &#38;&#38; result;
<span class="no">13</span>         }
<span class="no">14</span>         Listener::end(s,info);
<span class="no">15</span>         <span class="r">return</span> result;
<span class="no">16</span>     }
<span class="no">17</span> <span class="di">private</span>:
<span class="no">18</span>     <span class="pt">bool</span> runit(test <span class="di">const</span> &#38;t){
<span class="no">19</span>         <span class="r">try</span> {
<span class="no"><strong>20</strong></span>             Listener::start(t);
<span class="no">21</span>             t();
<span class="no">22</span>             Listener::success(t,<span class="s"><span class="dl">&quot;</span><span class="k">OK</span><span class="dl">&quot;</span></span>);
<span class="no">23</span>             <span class="r">return</span> <span class="pc">true</span>;
<span class="no">24</span>         } <span class="r">catch</span> (test_failure <span class="di">const</span> &#38;e){
<span class="no">25</span>             Listener::failure(t,e);
<span class="no">26</span>         } <span class="r">catch</span>(...) {
<span class="no">27</span>             Listener::error(t,<span class="s"><span class="dl">&quot;</span><span class="k">unknown exception thrown</span><span class="dl">&quot;</span></span>);
<span class="no">28</span>         }
<span class="no">29</span>         <span class="r">return</span> <span class="pc">false</span>;
<span class="no"><strong>30</strong></span>     }
<span class="no">31</span> };
</span></code></pre>

	<p>If you look back to runner::runit(), you will recognize that if any reasonable exception is thrown, it would be hard to diagnose the reason for the error. Therefore, I included catch clauses for std::exception, string and char pointers to get information required for diagnosis. The demangling is required for GNU g++ to get a human-readable information from the exception's class name.</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> } <span class="r">catch</span> (std::exception <span class="di">const</span> &#38;exc){
<span class="no">2</span>     Listener::error(t,test::demangle(exc.what()).c_str());
<span class="no">3</span> } <span class="r">catch</span> (std::<span class="pt">string</span> &#38;s){
<span class="no">4</span>     Listener::error(t,s.c_str());
<span class="no">5</span> } <span class="r">catch</span> (<span class="pt">char</span> <span class="di">const</span> *&#38;cs) {
<span class="no">6</span>     Listener::error(t,cs);
<span class="no">7</span> }
</span></code></pre>

	<p>Again I ask you for feedback if doing this seems over-engineered. Are you throwing strings as error indicators?</p>


	<p>As you can see, there are a bunch of methods delegated to the base class given as runner's template parameter (begin, end, start, success, failure, error). The default template parameter null_listener applies the Null Object design pattern and provides the concept all fitting Listener base classes.</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="r">struct</span> null_listener{ <span class="c">// defines Contract of runner parameter</span>
<span class="no">2</span>     <span class="di">void</span> begin(suite <span class="di">const</span> &#38;s, <span class="pt">char</span> <span class="di">const</span> *info){}
<span class="no">3</span>     <span class="di">void</span> end(suite <span class="di">const</span> &#38;s, <span class="pt">char</span> <span class="di">const</span> *info){}
<span class="no">4</span>     <span class="di">void</span> start(test <span class="di">const</span> &#38;t){}
<span class="no">5</span>     <span class="di">void</span> success(test <span class="di">const</span> &#38;t,<span class="pt">char</span> <span class="di">const</span> *msg){}
<span class="no">6</span>     <span class="di">void</span> failure(test <span class="di">const</span> &#38;t,test_failure <span class="di">const</span> &#38;e){}
<span class="no">7</span>     <span class="di">void</span> error(test <span class="di">const</span> &#38;t,<span class="pt">char</span> <span class="di">const</span> *what){}
<span class="no">8</span> };
</span></code></pre>

	<p>Whenever you need to collect the test results or you want to have a nice GUI showing progress with the tests, you can create your own custom listener.</p>


	<p>Again you can stack listeners using an inverted version of a Decorator design pattern [GoF]. Here is an example of an inverted Decorator using C++ templates that counts the number of tests by category:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="r">template</span> &lt;<span class="r">typename</span> Listener=null_listener&gt;
<span class="no"> 2</span> <span class="r">struct</span> counting_listener:Listener{
<span class="no"> 3</span>     counting_listener()
<span class="no"> 4</span>     :Listener()
<span class="no"> 5</span>     ,numberOfTests(<span class="i">0</span>),successfulTests(<span class="i">0</span>)
<span class="no"> 6</span>     ,failedTests(<span class="i">0</span>),errors(<span class="i">0</span>),numberOfSuites(<span class="i">0</span>){}
<span class="no"> 7</span> 
<span class="no"> 8</span>     counting_listener(Listener <span class="di">const</span> &#38;s)
<span class="no"> 9</span>     :Listener(s)
<span class="no"><strong>10</strong></span>     ,numberOfTests(<span class="i">0</span>),successfulTests(<span class="i">0</span>)
<span class="no">11</span>     ,failedTests(<span class="i">0</span>),errors(<span class="i">0</span>),numberOfSuites(<span class="i">0</span>){}
<span class="no">12</span> 
<span class="no">13</span>     <span class="di">void</span> begin(suite <span class="di">const</span> &#38;s, <span class="pt">char</span> <span class="di">const</span> *info){
<span class="no">14</span>         ++numberOfSuites;
<span class="no">15</span>         Listener::begin(s,info);
<span class="no">16</span>     }
<span class="no">17</span>     <span class="di">void</span> start(test <span class="di">const</span> &#38;t){
<span class="no">18</span>         ++numberOfTests;
<span class="no">19</span>         Listener::start(t);
<span class="no"><strong>20</strong></span>     }
<span class="no">21</span>     <span class="di">void</span> success(test <span class="di">const</span> &#38;t,<span class="pt">char</span> <span class="di">const</span> *msg){
<span class="no">22</span>         ++successfulTests;
<span class="no">23</span>         Listener::success(t,msg);
<span class="no">24</span>     }
<span class="no">25</span>     <span class="di">void</span> failure(test <span class="di">const</span> &#38;t,test_failure <span class="di">const</span> &#38;e){
<span class="no">26</span>         ++failedTests;
<span class="no">27</span>         Listener::failure(t,e);
<span class="no">28</span>     }
<span class="no">29</span>     <span class="di">void</span> error(test <span class="di">const</span> &#38;t,<span class="pt">char</span> <span class="di">const</span> *what){
<span class="no"><strong>30</strong></span>         ++errors;
<span class="no">31</span>         Listener::error(t,what);
<span class="no">32</span>     }
<span class="no">33</span>     <span class="pt">int</span> numberOfTests;
<span class="no">34</span>     <span class="pt">int</span> successfulTests;
<span class="no">35</span>     <span class="pt">int</span> failedTests;
<span class="no">36</span>     <span class="pt">int</span> errors;
<span class="no">37</span>     <span class="pt">int</span> numberOfSuites;
<span class="no">38</span> };
</span></code></pre>

	<p>From the above schema, you can derive your own stackable listener classes, such as a listener that displays in a GUI the progress and results of tests as they run. If you do so, please share your solution.</p>


	<p>Member Functions as Tests</p>


	<p>With boost::bind() at your disposal, it is easy to construct a functor object from a class and its member function. Again this is canned in a macro that can be used like this:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> CUTE_MEMFUN(testobject,TestClass,test1);
<span class="no">2</span> CUTE_SMEMFUN(TestClass,test2);
<span class="no">3</span> CUTE_CONTEXT_MEMFUN(contextobject,TestClass,test3);
</span></code></pre>

	<p>The first version uses object testobject, an instance of TestClass, as the target for the member function test1. The second version creates a new instance of TestClass to then call its member function test2 when the test is executed. The last macro provides a means to pass an additional object to TestClass' constructor when it is incarnated. The idea of incarnating the test object and thus have its constructor and destructor run as part of the test comes from Kevlin Henney and is implemented in Paul Grenyer's testing framework Aeryn.</p>


	<p>The macro CUTE_MEMFUN delegates its work to a template function as follows:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no">1</span> <span class="r">template</span> &lt;<span class="r">typename</span> TestClass&gt;
<span class="no">2</span> test makeMemberFunctionTest(TestClass &#38;t,<span class="di">void</span> (TestClass::*fun)(),<span class="pt">char</span> <span class="di">const</span> *name){
<span class="no">3</span>     <span class="r">return</span> test(boost::bind(fun,boost::ref(t)),test::demangle(<span class="r">typeid</span>(TestClass).name())+<span class="s"><span class="dl">&quot;</span><span class="k">::</span><span class="dl">&quot;</span></span>+name);
<span class="no">4</span> }
<span class="no">5</span> <span class="pp">#define</span> CUTE_MEMFUN(testobject,TestClass,MemberFunctionName) \
<span class="no">6</span>     cute::makeMemberFunctionTest(testobject,\
<span class="no">7</span>         &#38;TestClass::MemberFunctionName, <span class="pp">#MemberFunctionName</span>)
</span></code></pre>

	<p>When the template function makeMemberFunctionTest is called, it employs boost::bind to create a functor object that will call the member function fun on object t. Again we can employ C++ reflection using typeid to derive part of the test object's name. We need to derive the member function name again using the preprocessor with a macro. In order to also allow const member functions, the template function comes in two overloads, one using a reference (as shown) and the other using a const reference for the testing object.</p>


	<h2 id="Test-Object-Incarnation">Test Object Incarnation<a href="#Test-Object-Incarnation" class="wiki-anchor">&para;</a></h2>


	<p>I will spare you the details, and just present the mechanism of object incarnation and then calling a member function for the case where you can supply a context object:</p>


<pre><code class="cpp syntaxhl"><span class="CodeRay"><span class="no"> 1</span> <span class="r">template</span> &lt;<span class="r">typename</span> TestClass,<span class="r">typename</span> MemFun, <span class="r">typename</span> Context&gt;
<span class="no"> 2</span> <span class="r">struct</span> incarnate_for_member_function_with_context_object {
<span class="no"> 3</span>     MemFun memfun;
<span class="no"> 4</span>     Context context;
<span class="no"> 5</span>     incarnate_for_member_function_with_context_object(MemFun f,Context c)
<span class="no"> 6</span>     :memfun(f),context(c){}
<span class="no"> 7</span>     <span class="di">void</span> <span class="di">operator</span>()(){
<span class="no"> 8</span>         TestClass t(context);
<span class="no"> 9</span>         (t.*memfun)();
<span class="no"><strong>10</strong></span>     }
<span class="no">11</span> };
<span class="no">12</span> <span class="r">template</span> &lt;<span class="r">typename</span> TestClass, <span class="r">typename</span> MemFun, <span class="r">typename</span> Context&gt;
<span class="no">13</span> test makeMemberFunctionTestWithContext(Context c,MemFun fun,<span class="pt">char</span> <span class="di">const</span> *name){
<span class="no">14</span>     <span class="r">return</span> test(incarnate_for_member_function_with_context_object&lt;TestClass,MemFun,Context&gt;(fun,c),test::demangle(<span class="r">typeid</span>(TestClass).name())+<span class="s"><span class="dl">&quot;</span><span class="k">::</span><span class="dl">&quot;</span></span>+name);
<span class="no">15</span> }
</span></code></pre>

	<p>This allows you to use test classes with a constructor to set up a test fixture and a destructor for cleaning up after the test. This eliminates need to for explicit setUp() and tearDown() methods, as in JUnit.</p>


	<h2 id="Limitations-and-Outlook">Limitations and Outlook<a href="#Limitations-and-Outlook" class="wiki-anchor">&para;</a></h2>


	<p>One big difference between C++ and other languages is the lack of method-level introspection. The only way to create a list of tests to execute is for a programmer specify it by registering test objects somewhere. Our CUTE Eclipse plug-in eases that task by automatically registering test functions and methods for you in the current file's suite object.</p>


	<h2 id="Conclusion">Conclusion<a href="#Conclusion" class="wiki-anchor">&para;</a></h2>


	<p>With version 1.5 and its Eclipse CDT plug-in, CUTE left its nascent state. It comes with a small test suite for itself, but it may still have problems that I have not yet encountered. If you have not yet written unit tests for your code, try starting now using CUTE via its Eclipse plug-in and tell us how it feels and how it works for you.</p>


	<p>If you have more ideas for extending CUTE to make it a more convenient environment. Tell me your ideas, or just implement them. Thank you in advance.</p>


	<h2 id="References">References<a href="#References" class="wiki-anchor">&para;</a></h2>


	<ul>
	<li>Aeryn
	<ul>
	<li>Paul Grenyer <a class="external" href="http://www.aeryn.co.uk/">http://www.aeryn.co.uk</a></li>
	</ul>
	</li>
		<li>CppUnit
	<ul>
	<li><a class="external" href="http://cppunit.sourceforge.net/cppunit-wiki">http://cppunit.sourceforge.net/cppunit-wiki</a></li>
	</ul>
	</li>
		<li>Unit Testing Cookbook
	<ul>
	<li><a class="external" href="http://cppunit.sourceforge.net/doc/lastest/cppunit_cookbook.html">http://cppunit.sourceforge.net/doc/lastest/cppunit_cookbook.html</a></li>
	</ul>
	</li>
		<li>GoF
	<ul>
	<li>Gang of Four, E. Gamma, R. Helm, R. Johnson, J. Vlissides: Design Patterns - Elements of Reusable Object-Oriented Design</li>
	</ul>
	</li>
		<li>JUTLAND
	<ul>
	<li>Kevlin Henney, "Java Unit Testing Light Adaptable 'N Discreet", presentation at JAOO 2005 and private communication</li>
	</ul></li>
	</ul>
</div>














        
				<div style="clear:both;"></div>
    </div>
</div>

<div id="ajax-indicator" style="display:none;"><span>Loading...</span></div>
	
<div id="footer">
  <div class="bgl"><div class="bgr">
    Powered by <a href="http://www.redmine.org/">Redmine</a> &copy; 2006-2010 Jean-Philippe Lang
  </div></div>
</div>
</div>
</div>
<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-22096374-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>
</body>

</html>
