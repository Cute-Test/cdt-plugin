//!ShouldIgnoreFunctions
//@main.cpp
int foo() { return 0; }

//!ShouldIgnoreFunctionDeclarations
//@main.cpp
int foo();

//!ShouldIgnoreFunctionCalls
//@main.cpp
int foo() {}
int main() {
    foo();
}
	
//!ShouldIgnoreEqualsInitializedWithNarrowingTypeConversion
//@main.cpp
int x = 1.1;

//!ShouldIgnoreEqualsInitializedWithNarrowingTypeConversionInConstructor
//@main.cpp
struct T{ T(int x){}};
T x = 1.1;

//!ShouldIgnoreEqualsInitializedWithoutImplicitCopyConstructor
//@main.cpp
struct S{ S(int x){}};
struct T{ };
T x = S(1);

//!ShouldIgnoreDirectInitializedWithoutConversionConstructor
//@main.cpp
struct T{ T(int x){}};
T x(1.1);

//!ShouldIgnoreDirectInitilaizedMultiWithoudConversionConstructor
//@main.cpp
struct T{ T(double x, int y){}};
T x(1.1, 1.2);

//!ShouldIgnoreAlreadyElevatedInitializerList
//@main.cpp
int x{1};

//!ShouldIgnoreMultipleAlreadyElevatedInitializerList
//@main.cpp
int x{1}, y{};

//!ShouldIgnoreUninitializedReference
//@main.cpp
int &x;

//!ShouldIgnoreDeclarationsWithinClasses
//@main.cpp
struct Person { int age; };

//!ShouldIgnoreTeplateArguments
//@main.cpp
namespace std { template<class T1, class T2> class pair {}; }
std::pair<int,int> p1 { 3, 4 };

//!ShouldIgnoreTeplateArgumentPointers
//@main.cpp
namespace std { template<class T1, class T2> class pair {}; }
std::pair<int*,int*> p1 { 3, 4 };

//!ShouldIgnoreInitializerListConstructor
//@main.cpp
namespace std { template<class _E> class initializer_list {}; }
struct A { A(std::initializer_list<int> l) {}
          void someFoo(std::initializer_list<int> l){}};
A a(0);

//!ShouldIgnoreBoostAssign
//@main.cpp
namespace boost {
  template <class K, class T>
  struct unordered_map{
    unordered_map<int, double> operator()(int, double) {
      return unordered_map<int, double>(); }
  };
  namespace assign {
    unordered_map<int, double> map_list_of(int, double){return unordered_map<int, double>();}
  }
}
boost::unordered_map<int, double> map = boost::assign::map_list_of
(1, 3.1)
(2, 3.2);

//!ShouldIgnoreRenamedBoostAssign
//@main.cpp
namespace boost {
  template <class K, class T>
  struct unordered_map{
  unordered_map<int, double> operator()(int, double) {
    return unordered_map<int, double>(); }
  };
  namespace assign {
    unordered_map<int, double> map_list_of(int, double){return unordered_map<int, double>();}
  }
}
namespace X = boost::assign;
boost::unordered_map<int, double> map = X::map_list_of
(1, 3.1)
(2, 3.2);

//!ShouldIgnoreUsingNamespaceBoostAssign
//@main.cpp
namespace boost {
   template <class K, class T>
   struct unordered_map{
       unordered_map<int, double> operator()(int, double) {
           return unordered_map<int, double>(); }
   };
   namespace assign {
       unordered_map<int, double> map_list_of(int, double){return unordered_map<int, double>();}
   }
}
using namespace boost::assign;
boost::unordered_map<int, double> map = map_list_of
(1, 3.1)
(2, 3.2);

//!ShouldIgnoreElevatedConstructorInitList
//@main.cpp
class C { int a; int b; };
C::C() :a{1}, b{2} {}

//!ShouldIgnoreCastExpressions
//@main.cpp
int function(int n) {
    return *(int*)(&n);
}

//!ShouldIgnoreDeclarationWithTypeAuto
//@main.cpp
int main() {
	auto a;
}

//!ShouldIgnoreDeclarationWithTypeAutoAndEqualsInitializer
//@main.cpp
int main() {
	auto a = 5;
}

//!ShouldIgnoreDeclarationWithTypeAuto
//@main.cpp
int main() {
	auto a;
}

//!ShouldIgnoreDeclarationWithTypeAutoAndCopyConstructor
//@main.cpp
int main() {
	auto a(5);
}

//!ShouldIgnoreConstexprDeclarationWithTypeAuto
//@main.cpp
constexpr auto a = 5;
int main() {
	return 0;
}

//!ShouldIgnoreElevatedClasses
//@main.cpp
class C {};

int main() {
	new C { };
}

//!ShouldIgnoreReferenceInitializationInConstructorInitList
//@main.cpp

struct S {};

struct T
{
    T(S& s) : s(s) {}

    S& s;
};


