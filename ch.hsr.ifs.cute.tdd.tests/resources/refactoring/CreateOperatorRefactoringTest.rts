//!PrefixOperator
//@A.cpp
struct B
{
};

void func()
{
    B b;
    ++b;
}
//=
struct B
{
    B & operator++()
    {
        return B();
    }
};

void func()
{
    B b;
    ++b;
}
//!PostfixOperator
//@A.cpp
struct B
{
};

void func()
{
    B b;
    b++;
}
//=
struct B
{
    B operator++(int)
    {
        return B();
    }
};

void func()
{
    B b;
    b++;
}
//!BinaryOperatorTest
//@Test.cpp
struct B
{
};

void func()
{
    B b;
    B b1;
    b==b1;
}
//=
struct B
{
    bool operator==(B & b1) const
    {
        return bool();
    }
};

void func()
{
    B b;
    B b1;
    b==b1;
}
//!FindsGoodUnaryOperator
//@.config
markerCount=0
//@Test.cpp
struct B
{
    void operator++()
    {
    }
};

void func()
{
    B b;
    ++b;
}
//=
struct B
{
    void operator++()
    {
    }
};

void func()
{
    B b;
    ++b;
}
//!FindsGoodBinaryOperator
//@.config
markerCount=0
//@Test.cpp
struct B
{
    bool operator==(int) const
    {
        return int();
    }
};

void func()
{
    B b;
    b==3;
}
//=
struct B
{
    bool operator==(int) const
    {
        return int();
    }
};

void func()
{
    B b;
    b==3;
}
//!Recognize Enum Assignment As OK
//@.config
markerCount=0
//@Test.cpp
typedef enum {RED, GREEN, BLUE} Color;

void thisIsATest() {
	Color c;
	c = RED;
}
//=
typedef enum {RED, GREEN, BLUE} Color;

void thisIsATest() {
	Color c;
	c = RED;
}
//!ASSERTOperatorDectectionUnary
//@Test.cpp
#include <string>
namespace cute{
    struct test_failure {
        std::string reason;
        std::string filename;
        int lineno;

        test_failure(std::string const &r,char const *f, int line)
        :reason(r),filename(f),lineno(line)
        {   }
        char const * what() const { return reason.c_str(); }
    };
}
#define ASSERTM(msg,cond) if (!(cond)) throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)

struct A {
};

void test(){
    A a;   
    ASSERT(a++);
}
//=
#include <string>
namespace cute{
    struct test_failure {
        std::string reason;
        std::string filename;
        int lineno;

        test_failure(std::string const &r,char const *f, int line)
        :reason(r),filename(f),lineno(line)
        {   }
        char const * what() const { return reason.c_str(); }
    };
}
#define ASSERTM(msg,cond) if (!(cond)) throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)

struct A {
    A operator++(int)
    {
        return A();
    }
};

void test(){
    A a;   
    ASSERT(a++);
}
//!ASSERT_EQUALSOperatorDetectionUnary
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue>
        void assert_equal(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,char const *msg
                    ,char const *file
                    ,int line) {
            // unfortunately there is no is_integral_but_not_bool_or_enum
            typedef typename impl_place_for_traits::is_integral<ExpectedValue> exp_integral;
            typedef typename impl_place_for_traits::is_integral<ActualValue> act_integral;
    }
}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))

struct A {
};
void test(){
    A a;
    ASSERT_EQUAL(6, a++);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue>
        void assert_equal(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,char const *msg
                    ,char const *file
                    ,int line) {
            // unfortunately there is no is_integral_but_not_bool_or_enum
            typedef typename impl_place_for_traits::is_integral<ExpectedValue> exp_integral;
            typedef typename impl_place_for_traits::is_integral<ActualValue> act_integral;
    }
}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))

struct A {
    int operator++(int)
    {
        return int();
    }
};
void test(){
    A a;
    ASSERT_EQUAL(6, a++);
}
//!ASSERT_EQUALS_DELTA_Operator_DetectionUnary
//@.config
markerCount=2
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
};
void test(){
    A a;
    ASSERT_EQUAL_DELTA(6, a++, 0.0);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
    int operator++(int)
    {
        return int();
    }
};
void test(){
    A a;
    ASSERT_EQUAL_DELTA(6, a++, 0.0);
}
//!ASSERT_EQUALS_DELTA_M_Operator_DetectionUnary
//@.config
markerCount=2
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
};
void test(){
    A a;
    ASSERT_EQUAL_DELTAM("foobar", 6, a++, 0.0);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
    int operator++(int)
    {
        return int();
    }
};
void test(){
    A a;
    ASSERT_EQUAL_DELTAM("foobar", 6, a++, 0.0);
}
//!ASSERTOperatorDectectionBinary
//@Test.cpp
#include <string>
namespace cute{
    struct test_failure {
        std::string reason;
        std::string filename;
        int lineno;

        test_failure(std::string const &r,char const *f, int line)
        :reason(r),filename(f),lineno(line)
        {   }
        char const * what() const { return reason.c_str(); }
    };
}
#define ASSERTM(msg,cond) if (!(cond)) throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)

struct A {
};

void test(){
    A a;   
    ASSERT(a==3);
}
//=
#include <string>
namespace cute{
    struct test_failure {
        std::string reason;
        std::string filename;
        int lineno;

        test_failure(std::string const &r,char const *f, int line)
        :reason(r),filename(f),lineno(line)
        {   }
        char const * what() const { return reason.c_str(); }
    };
}
#define ASSERTM(msg,cond) if (!(cond)) throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)

struct A {
    bool operator==(const int & i) const
    {
        return bool();
    }
};

void test(){
    A a;   
    ASSERT(a==3);
}
//!ASSERT_EQUALSOperatorDetectionBinary
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue>
        void assert_equal(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,char const *msg
                    ,char const *file
                    ,int line) {
            // unfortunately there is no is_integral_but_not_bool_or_enum
            typedef typename impl_place_for_traits::is_integral<ExpectedValue> exp_integral;
            typedef typename impl_place_for_traits::is_integral<ActualValue> act_integral;
    }
}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))

struct A {
};
void test(){
    A a;
    ASSERT_EQUAL(true, a==3);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue>
        void assert_equal(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,char const *msg
                    ,char const *file
                    ,int line) {
            // unfortunately there is no is_integral_but_not_bool_or_enum
            typedef typename impl_place_for_traits::is_integral<ExpectedValue> exp_integral;
            typedef typename impl_place_for_traits::is_integral<ActualValue> act_integral;
    }
}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))

struct A {
    bool operator==(const int & i) const
    {
        return bool();
    }
};
void test(){
    A a;
    ASSERT_EQUAL(true, a==3);
}
//!ASSERT_EQUALS_DELTA_Operator_DetectionBinary
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
};
void test(){
    A a;
    ASSERT_EQUAL_DELTA(true, a==3, 0.0);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
    bool operator==(const int & i) const
    {
        return bool();
    }
};
void test(){
    A a;
    ASSERT_EQUAL_DELTA(true, a==3, 0.0);
}
//!ASSERT_EQUALS_DELTA_M_Operator_DetectionBinary
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
};
void test(){
    A a;
    ASSERT_EQUAL_DELTAM("foobar", true, a==3, 0.0);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct A {
    bool operator==(const int & i) const
    {
        return bool();
    }
};
void test(){
    A a;
    ASSERT_EQUAL_DELTAM("foobar", true, a==3, 0.0);
}
//!BoostOperatorDetectionPreFix
//@A.cpp
#include "boost/operators.hpp"

struct A : boost::operators<A>
{
};

void thisIsATest() {
    A a;
    ++a;
}
//=
#include "boost/operators.hpp"

struct A : boost::operators<A>
{
    A & operator++()
    {
        return A();
    }
};

void thisIsATest() {
    A a;
    ++a;
}
//!FindFreePrefixOperator
//@.config
markerCount=0
//@A.cpp
struct A {
};

void operator++(A & a) 
{}

void test() {
    A a;
    ++a;
}
//=
struct A {
};

void operator++(A & a) 
{}

void test() {
    A a;
    ++a;
}
//!FindFreePostFixOperator
//@.config
markerCount=0
//@A.cpp
struct A {
};

void operator++(A & a, int) 
{}

void test() {
    A a;
    a++;
}
//=
struct A {
};

void operator++(A & a, int) 
{}

void test() {
    A a;
    a++;
}
//!FindUnaryOperatorOnBaseType
//@.config
markerCount=0
//@A.cpp
void test()
{
    int a = 3;
    a++;
}
//=
void test()
{
    int a = 3;
    a++;
}
//!FindBinaryOperatorOnBaseType
//@.config
markerCount=0
//@A.cpp
void test()
{
    int a = 3;
    a==3;
    a*a;
}
//=
void test()
{
    int a = 3;
    a==3;
    a*a;
}
//!DoNotReportIfOperandNotDefined
//@.config
markerCount=0
//@A.cpp
void test() {
    a++;
}
//=
void test() {
    a++;
}
//!Do Not Report If Operand Not Defined in Binary Expression
//@.config
markerCount=0
//@A.cpp
void test() {
	i = 5;
}
//=
void test() {
	i = 5;
}
//!Do Not Report Not Operator for Pointer Types
//@.config
markerCount=0
//@A.cpp
void foo(){
	void *x=0;
	ASSERT(!x);
}
//=
void foo(){
	void *x=0;
	ASSERT(!x);
}
