//!TestSimpleMemberFunction
//@A.cpp
struct B
{
};

void func()
{
    B b1;
    b1.member();
}
//=
struct B
{
    void member()
    {
    }
};

void func()
{
    B b1;
    b1.member();
}
//!TestAssigmentMemberFunction
//@A.cpp
struct B
{
};

void func()
{
    B b1;
    int x = b1.member();
}
//=
struct B
{
    int member() const
    {
        return int();
    }
};

void func()
{
    B b1;
    int x = b1.member();
}
//!TestSimpleMacro
//@A.cpp
#define MACRO(c) c()

struct B
{
};

void func()
{
    B b1;
    MACRO(b1.member());
}
//=
#define MACRO(c) c()

struct B
{
    void member()
    {
    }
};

void func()
{
    B b1;
    MACRO(b1.member());
}
//!TestOtherFileMember
//@A.cpp
#include "B.h"

void func()
{
    B b1;
    b1.member();
}
//=
#include "B.h"

void func()
{
    B b1;
    b1.member();
}
//@B.h
struct B
{
};
//=
struct B
{
    void member()
    {
    }
};
//!PrivateClassInsertion
//@A.cpp
class B {
};

void test()
{
    B b;
    b.foo();
}
//=
class B {
public:
    void foo()
    {
    }
};

void test()
{
    B b;
    b.foo();
}
//!AdvancedPrivateClass
//@A.cpp
class B {
protected:
public:
private:
};

void test()
{
    B b;
    b.foo();
}
//=
class B {
protected:
public:
    void foo()
    {
    }
private:
};

void test()
{
    B b;
    b.foo();
}
//!TestCuteMacroFunctionCreation_ASSERT
//@Test.cpp
#include <string>
namespace cute{
    struct test_failure {
        std::string reason;
        std::string filename;
        int lineno;

        test_failure(std::string const &r,char const *f, int line)
        :reason(r),filename(f),lineno(line)
        {   }
        char const * what() const { return 0; }
    };
}
#define ASSERTM(msg,cond) if (!(cond)) throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)

struct B
{
};

void blah(){
    B b1;
    ASSERT(b1.member());
}
//=
#include <string>
namespace cute{
    struct test_failure {
        std::string reason;
        std::string filename;
        int lineno;

        test_failure(std::string const &r,char const *f, int line)
        :reason(r),filename(f),lineno(line)
        {   }
        char const * what() const { return 0; }
    };
}
#define ASSERTM(msg,cond) if (!(cond)) throw cute::test_failure((msg),__FILE__,__LINE__)
#define ASSERT(cond) ASSERTM(#cond,cond)

struct B
{
    bool member() const
    {
        return bool();
    }
};

void blah(){
    B b1;
    ASSERT(b1.member());
}
//!TestCuteMacroFunctionCreation_ASSERT_EQUALS
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue>
        void assert_equal(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,char const *msg
                    ,char const *file
                    ,int line) {
            // unfortunately there is no is_integral_but_not_bool_or_enum
            typedef typename impl_place_for_traits::is_integral<ExpectedValue> exp_integral;
            typedef typename impl_place_for_traits::is_integral<ActualValue> act_integral;
    }
}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))

struct B
{
};

void test(){
    B b1;
    ASSERT_EQUAL(42, b1.member());
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue>
        void assert_equal(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,char const *msg
                    ,char const *file
                    ,int line) {
            // unfortunately there is no is_integral_but_not_bool_or_enum
            typedef typename impl_place_for_traits::is_integral<ExpectedValue> exp_integral;
            typedef typename impl_place_for_traits::is_integral<ActualValue> act_integral;
    }
}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))

struct B
{
    int member() const
    {
        return int();
    }
};

void test(){
    B b1;
    ASSERT_EQUAL(42, b1.member());
}
//!TestCuteMacroFunctionCreation_ASSERT_EQUALS_DELTA
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct B
{
};

void testKreis(){
    B b;
    ASSERT_EQUAL_DELTA(42, b.member(), 0.0);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct B
{
    int member() const
    {
        return int();
    }
};

void testKreis(){
    B b;
    ASSERT_EQUAL_DELTA(42, b.member(), 0.0);
}
//!TestCuteMacroFunctionCreation_ASSERT_EQUALS_DELTA_M
//@Test.cpp
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct B
{
};

void testKreis(){
    B b;
    ASSERT_EQUAL_DELTAM("foobar", 42, b.member(), 0.0);
}
//=
namespace cute {
    template <typename ExpectedValue, typename ActualValue, typename DeltaValue>
        void assert_equal_delta(ExpectedValue const &expected
                    ,ActualValue const &actual
                    ,DeltaValue const &delta
                    ,char const *msg
                    ,char const *file
                    ,int line) {
        }
}
#define ASSERT_EQUAL_DELTAM(msg,expected,actual,delta) cute::assert_equal_delta((expected),(actual),(delta),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL_DELTA(expected,actual,delta) ASSERT_EQUAL_DELTAM(#expected " == " #actual " with error " #delta  ,(expected),(actual),(delta))

struct B
{
    int member() const
    {
        return int();
    }
};

void testKreis(){
    B b;
    ASSERT_EQUAL_DELTAM("foobar", 42, b.member(), 0.0);
}
//!StructPublicPartIfExiplicit
//@A.cpp
struct B {
public:
};

void test()
{
    B b;
    b.foo();
}
//=
struct B {
public:
    void foo()
    {
    }
};

void test()
{
    B b;
    b.foo();
}
//!MemberWithParameter
//@A.cpp
struct B
{
};

void func()
{
    B b1;
    b1.member(42);
}
//=
struct B
{
    void member(const int & i)
    {
    }
};

void func()
{
    B b1;
    b1.member(42);
}
//!CuteAssertEqualMemberWithParameter
//@A.cpp
namespace cute {
template <typename ExpectedValue, typename ActualValue>
	void assert_equal(ExpectedValue const &expected
		,ActualValue const &actual ,char const *msg
		,char const *file ,int line) {
}}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))
struct Type {};
void test(){
    Type t;
    ASSERT_EQUAL(42, t.function(42));
}
//=
namespace cute {
template <typename ExpectedValue, typename ActualValue>
	void assert_equal(ExpectedValue const &expected
		,ActualValue const &actual ,char const *msg
		,char const *file ,int line) {
}}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))
struct Type {
    int function(const int & i) const
    {
        return int();
    }};
void test(){
    Type t;
    ASSERT_EQUAL(42, t.function(42));
}
//!No Suggestion for Members of Fundamental Types
//@.config
nomarkers=true
//@A.cpp
void test()
{
	int i = 5;
	i.foo();
}
//=
void test()
{
	int i = 5;
	i.foo();
}
//!Create Member Function with One Argument and Return Type
//@A.cpp
struct A{
};

int main(int argc, char **argv) {
	A a;
	A b = a.create(1);
}

//=
struct A{
    A create(const int & i) const
    {
        return A();
    }
};

int main(int argc, char **argv) {
	A a;
	A b = a.create(1);
}

