//!SimpleInt
//@A.cpp
struct A {
};

void test()
{
    A a(1);
}
//=
struct A {
     A(const int & i)
    {
    }
};

void test()
{
    A a(1);
}
//!SimpleDouble
//@A.cpp
struct A {
};

void test()
{
    A a(1.0);
}
//=
struct A {
     A(const double & d)
    {
    }
};

void test()
{
    A a(1.0);
}
//!MultipleArgumentsJustOneParam
//@A.cpp
struct A {
     A(const int & i)
    {
    }
};

void test()
{
    A a(2, 2);
}
//=
struct A {
     A(const int & i, const int & j)
    {
    }

    A(const int & i)
    {
    }
};

void test()
{
    A a(2, 2);
}
//!OneArgMultipleParam
//@A.cpp
struct A {
    A(const int & i, const int & j)
    {
    }
};

void test()
{
    A a(2);
}
//=
struct A {
    A(const int & i)
    {
    }

    A(const int & i, const int & j)
    {
    }
};

void test()
{
    A a(2);
}
//!TypeArgument
//@A.cpp
struct Type {
};

struct A {
};

void test()
{
    Type t;
    A a(t);
}
//=
struct Type {
};

struct A {
     A(Type & t)
    {
    }
};

void test()
{
    Type t;
    A a(t);
}
//!SameParameterLength
//@A.cpp
struct A {
    A(const std::string & s, const int & i)
    {
    }
};

void test()
{
    A a(1, 1);
}
//=
struct A {
    A(const int & i, const int & j)
    {
    }

    A(const std::string & s, const int & i)
    {
    }
};

void test()
{
    A a(1, 1);
}
//!Create Constructor from Function Call Expression
//@A.cpp
struct Rnd {
    int getInt(){
        return 4; //Random number determined by rolling a die
    }
};

struct A {
};

void test()
{
    Rnd r;
    A a(r.getInt());
}
//=
struct Rnd {
    int getInt(){
        return 4; //Random number determined by rolling a die
    }
};

struct A {
     A(const int & rgetInt)
    {
    }
};

void test()
{
    Rnd r;
    A a(r.getInt());
}
//!Create Constructor from Chained Function Call Expression
//@A.cpp
struct Rnd {
    int getInt(){
        return 4; //Random number determined by rolling a die
    }
};

struct A {
};

Rnd getRnd(){
  return Rnd();
}

void test()
{
    Rnd r;
    A a(getRnd().getInt());
}
//=
struct Rnd {
    int getInt(){
        return 4; //Random number determined by rolling a die
    }
};

struct A {
     A(const int & getRndgetInt)
    {
    }
};

Rnd getRnd(){
  return Rnd();
}

void test()
{
    Rnd r;
    A a(getRnd().getInt());
}
//!Find Matching Constructor
//@.config
nomarkers=true
//@A.cpp
struct A {
    A(const int & i, const int & j)
    {
    }
};

void test()
{
    A a(1, 1);
}
//=
struct A {
    A(const int & i, const int & j)
    {
    }
};

void test()
{
    A a(1, 1);
}
//!Find Constructor from Function Call Expression
//@.config
nomarkers=true
//@A.cpp
struct Rnd {
    int getInt(){
        return 4; //Random number determined by rolling a die
    }
};

struct A {
     A(const int & rgetInt)
    {
    }
};

void test()
{
    Rnd r;
    A a(r.getInt());
}
//=
struct Rnd {
    int getInt(){
        return 4; //Random number determined by rolling a die
    }
};

struct A {
     A(const int & rgetInt)
    {
    }
};

void test()
{
    Rnd r;
    A a(r.getInt());
}
//!No Constructor for Typedef Enum
//@.config
nomarkers=true
//@A.cpp
typedef enum {RED, GREEN, BLUE} Color;

void test() {
	Color c;
}
//=
typedef enum {RED, GREEN, BLUE} Color;

void test() {
	Color c;
}
//!No Constructor for Composite Type Member
//@.config
nomarkers=true
//@A.cpp
struct A{
};
struct S{
	A memberA;
};
//=
struct A{
};
struct S{
	A memberA;
};
//!No Constructor for Reference Initialization
//@.config
nomarkers=true
//@A.cpp
struct A {
};

void test()
{
	A a1;
    A & a2(a1);
}
//=
struct A {
};

void test()
{
	A a1;
    A & a2(a1);
}
//!No Constructor for Pointer Initialization
//@.config
nomarkers=true
//@A.cpp
struct A {
};

void test()
{
	A a1;
    A * a2(&a1);
}
//=
struct A {
};

void test()
{
	A a1;
    A * a2(&a1);
}
//!No Constructor for Typedef Reference Initialization
//@.config
nomarkers=true
//@A.cpp
struct A {
};

typedef A & AToo;

void test()
{
	A a1;
    AToo a2(a1);
}
//=
struct A {
};

typedef A & AToo;

void test()
{
	A a1;
    AToo a2(a1);
}
//!No Constructor for Typdef Pointer Initialization
//@.config
nomarkers=true
//@A.cpp
struct A {
};

typedef A * AToo;

void test()
{
	A a1;
    AToo a2(&a1);
}
//=
struct A {
};

typedef A * AToo;

void test()
{
	A a1;
    AToo a2(&a1);
}
//!Default Ctor Needed
//@A.cpp
struct A {
    A(const int & i)
    {
    }
};

void test()
{
    A a(1);
    A b;
}
//=
struct A {
    A()
    {
    }

    A(const int & i)
    {
    }
};

void test()
{
    A a(1);
    A b;
}
//!Typedef Ctor Required
//@A.cpp
struct A {
};

typedef A AToo;

void test()
{
    AToo a(1);
}
//=
struct A {
     A(const int & i)
    {
    }
};

typedef A AToo;

void test()
{
    AToo a(1);
}
//!Composite Type Specifier Declaration
//@A.cpp
struct S {
} s(1);
//=
struct S {
     S(const int & i)
    {
    }
} s(1);
//!Local Composite Type Specifier Declaration
//@A.cpp
void test()
{
	struct S {
	} s(1);
}
//=
void test()
{
	struct S {
	     S(const int & i)
	    {
	    }
	} s(1);
}
//!Constructor for Multiple Declarators
//@A.cpp
struct S {
};

void test()
{
    S s1(1), s2(5);
}
//=	
struct S {
     S(const int & i)
    {
    }
};

void test()
{
    S s1(1), s2(5);
}
//!No Constructor for Array
//@.config
nomarkers=true
//@A.cpp
struct A {
};

void test()
{
	A a[2];
}
//=
struct A {
};

void test()
{
	A a[2];
}
//!ConstructorWithTemplate
//@A.cpp
template <typename T>
struct A {      
};

void test() {
    A<double> a(3);
}
//=
template <typename T>
struct A {
     A(const int & i)
    {
    }
};

void test() {
    A<double> a(3);
}