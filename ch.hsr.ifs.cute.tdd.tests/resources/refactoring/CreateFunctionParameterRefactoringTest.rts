//!SingleParameterInt
//@A.cpp
void func() {
    blah(42);
}
//=
void blah(const int& i) {
}

void func() {
    blah(42);
}
//!SingleParameterDouble
//@A.cpp
void func() {
    blah(42.0);
}
//=
void blah(const double& d) {
}

void func() {
    blah(42.0);
}
//!SingleParameterString
//@A.cpp
void func() {
    blah("foo");
}
//=
void blah(const std::string& s) {
}

void func() {
    blah("foo");
}
//!SingleParameterChar
//@A.cpp
void func() {
    blah('c');
}
//=
void blah(const char& c) {
}

void func() {
    blah('c');
}
//!SingleParameterTrue
//@A.cpp
void func() {
    blah(true);
}
//=
void blah(const bool& b) {
}

void func() {
    blah(true);
}
//!SingleParameterFalse
//@A.cpp
void func() {
    blah(false);
}
//=
void blah(const bool& b) {
}

void func() {
    blah(false);
}
//!SingleParameterThis
//@A.cpp
struct Klass {
	void func() {
		blah(this);
	}
};
//=
struct Klass {
	void blah(const Klass* const & k) {
	}

	void func() {
		blah(this);
	}
};
//!TwoDifferentParameters
//@A.cpp
void func() {
    blah(42, 42.0);
}
//=
void blah(const int& i, const double& d) {
}

void func() {
    blah(42, 42.0);
}
//!TwoSameParameters
//@A.cpp
void func() {
    blah(42, 42);
}
//=
void blah(const int& i, const int& j) {
}

void func() {
    blah(42, 42);
}
//!ParametersWithSameName
//@A.cpp
void func() {
    blah(42, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0);
}
//=
void blah(const int& i, const double& d, const double& e, const double& f,
		const double& g, const double& h, const double& j) {
}

void func() {
    blah(42, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0);
}
//!SymbolAsArgument
//@A.cpp
void func() {
    int id = 0;
    blah(id);
}
//=
void blah(int& id) {
}

void func() {
    int id = 0;
    blah(id);
}
//!SameSymbolMultipleTimes
//@A.cpp
void func() {
    int id = 0;
    blah(id, id, id);
}
//=
void blah(int& id, int& id1, int& id2) {
}

void func() {
    int id = 0;
    blah(id, id, id);
}
//!ClassAsArgument
//@A.cpp
struct Type {};
void func() {
    Type myType;
    blah(myType);
}
//=
struct Type {};
void blah(Type& myType) {
}

void func() {
    Type myType;
    blah(myType);
}
//!TwiceSameClassAsArgument
//@A.cpp
struct Type {};
void func() {
    Type myType;
    blah(myType, myType);
}
//=
struct Type {};
void blah(Type& myType, Type& myType1) {
}

void func() {
    Type myType;
    blah(myType, myType);
}
//!NestedFunctionWithParameter
//@A.cpp
void exists(int x) {}
void foo() {
    exists(func(42));
}
//=
void exists(int x) {}
void func(const int& i) {
}

void foo() {
    exists(func(42));
}
//!ReplaceFunctionNameMacro
//@A.cpp
#define MACRO exists
void exists(int x) {}
void foo() {
    MACRO(func(42));
}
//=
#define MACRO exists
void exists(int x) {}
void func(const int& i) {
}

void foo() {
    MACRO(func(42));
}
//!ReplaceFunctionMacro
//@A.cpp
#define MACRO(code) exists(code)
void exists(int x) {}
void foo() {
    MACRO(func(42));
}
//=
#define MACRO(code) exists(code)
void exists(int x) {}
void func(const int& i) {
}

void foo() {
    MACRO(func(42));
}
//!CUTEAssertEqualFunctionParameter
//@A.cpp
namespace cute {
template <typename ExpectedValue, typename ActualValue>
	void assert_equal(ExpectedValue const &expected
		,ActualValue const &actual ,char const *msg
		,char const *file ,int line) {
}}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))
void test(){
    ASSERT_EQUAL(42, function(42));
}
//=
namespace cute {
template <typename ExpectedValue, typename ActualValue>
	void assert_equal(ExpectedValue const &expected
		,ActualValue const &actual ,char const *msg
		,char const *file ,int line) {
}}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))
int function(const int& i) {
	return int();
}

void test(){
    ASSERT_EQUAL(42, function(42));
}
//!TestNotYetDefinedVariables
//@A.cpp
void test()
{
    func(2, 3, 2.3, var);
}
//=
void func(const int& i, const int& j, const double& d, const int& var) {
}

void test()
{
    func(2, 3, 2.3, var);
}
//!Pointer Parameter
//@A.cpp
struct P{};

void test()
{
    P * p;
    func(p);
}
//=
struct P{};

void func(P*& p) {
}

void test()
{
    P * p;
    func(p);
}
//!Pointer to Const Parameter
//@A.cpp
struct P{};

void test()
{
    P const * p;
    func(p);
}
//=
struct P{};

void func(const P*& p) {
}

void test()
{
    P const * p;
    func(p);
}
//!Const Pointer Parameter
//@A.cpp
struct P{};

void test()
{
    P * const p;
    func(p);
}
//=
struct P{};

void func(P* const & p) {
}

void test()
{
    P * const p;
    func(p);
}
//!Const Pointer to Const Parameter
//@A.cpp
struct P{};

void test()
{
    P const * const p;
    func(p);
}
//=
struct P{};

void func(const P* const & p) {
}

void test()
{
    P const * const p;
    func(p);
}
//!Const Volatile Pointer Parameter
//@A.cpp
struct P{};

void test()
{
    P * const volatile p;
    func(p);
}
//=
struct P{};

void func(P* const volatile & p) {
}

void test()
{
    P * const volatile p;
    func(p);
}
//!Pointer to Const Volatile Parameter
//@A.cpp
struct P{};

void test()
{
    P const volatile * p;
    func(p);
}
//=
struct P{};

void func(const volatile P*& p) {
}

void test()
{
    P const volatile * p;
    func(p);
}
//!Pointer Pointer Parameter
//@A.cpp
struct P{};

void test()
{
    P ** p;
    func(p);
}
//=
struct P{};

void func(P**& p) {
}

void test()
{
    P ** p;
    func(p);
}
//!Pointer Parameter from Expression
//@A.cpp
struct P{};

void test()
{
    func(new P());
}
//=
struct P{};

void func(P* const & newP) {
}

void test()
{
    func(new P());
}
//!Array Parameter
//@A.cpp
void test() {
	int iArr[];
	foo(iArr);
}
//=
void foo(int iArr[]) {
}

void test() {
	int iArr[];
	foo(iArr);
}
//!String Array Parameter (Local Definition of std::string)
//@A.cpp
namespace std
{
    struct string{};
}

void test(){
	std::string sArr[];
	foo(sArr);
}
//=
namespace std
{
    struct string{};
}

void foo(std::string sArr[]) {
}

void test(){
	std::string sArr[];
	foo(sArr);
}
//!Const Char Pointer from Non-Literal
//@A.cpp
void test(){
	const char * str = "Hello";
	foo(str);
}
//=
void foo(const char*& str) {
}

void test(){
	const char * str = "Hello";
	foo(str);
}
//!Create typedef-Type Parameter
//@A.cpp
typedef int I;

void test(){
    I i = 5;
	foo(i);
}
//=
typedef int I;

void foo(I& i) {
}

void test(){
    I i = 5;
	foo(i);
}
//!Create typedef-Returntype Parameter
//@A.cpp
typedef int I;

I getI(){
    return 23;
}

void test(){
	foo(getI());
}
//=
typedef int I;

I getI(){
    return 23;
}

void foo(const I& getI) {
}

void test(){
	foo(getI());
}
//!Create Constructor Call of typedef-Type
//@A.cpp
typedef int I;

void test(){
	foo(I(23));
}
//=
typedef int I;

void foo(const I& i) {
}

void test(){
	foo(I(23));
}
