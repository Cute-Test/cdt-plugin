//!SingleParameterInt
//@A.cpp
void func() {
    blah(42);
}
//=
void blah(const int & i)
{
}

void func() {
    blah(42);
}
//!SingleParameterDouble
//@A.cpp
void func() {
    blah(42.0);
}
//=
void blah(const double & d)
{
}

void func() {
    blah(42.0);
}
//!SingleParameterString
//@A.cpp
void func() {
    blah("foo");
}
//=
void blah(const std::string & s)
{
}

void func() {
    blah("foo");
}
//!SingleParameterChar
//@A.cpp
void func() {
    blah('c');
}
//=
void blah(const char & c)
{
}

void func() {
    blah('c');
}
//!SingleParameterTrue
//@A.cpp
void func() {
    blah(true);
}
//=
void blah(const bool & b)
{
}

void func() {
    blah(true);
}
//!SingleParameterFalse
//@A.cpp
void func() {
    blah(false);
}
//=
void blah(const bool & b)
{
}

void func() {
    blah(false);
}
//!SingleParameterThis
//@A.cpp
struct Klass {
    void func() {
        blah(this);
    }
};
//=
struct Klass {
    void blah(const Klass & k)
    {
    }

    void func() {
        blah(this);
    }
};
//!TwoDifferentParameters
//@A.cpp
void func() {
    blah(42, 42.0);
}
//=
void blah(const int & i, const double & d)
{
}

void func() {
    blah(42, 42.0);
}
//!TwoSameParameters
//@A.cpp
void func() {
    blah(42, 42);
}
//=
void blah(const int & i, const int & j)
{
}

void func() {
    blah(42, 42);
}
//!ParametersWithSameName
//@A.cpp
void func() {
    blah(42, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0);
}
//=
void blah(const int & i, const double & d, const double & e, const double & f, const double & g, const double & h, const double & j)
{
}

void func() {
    blah(42, 42.0, 42.0, 42.0, 42.0, 42.0, 42.0);
}
//!SymbolAsArgument
//@A.cpp
void func() {
    int id = 0;
    blah(id);
}
//=
void blah(int & id)
{
}

void func() {
    int id = 0;
    blah(id);
}
//!SameSymbolMultipleTimes
//@A.cpp
void func() {
    int id = 0;
    blah(id, id, id);
}
//=
void blah(int & id, int & id1, int & id2)
{
}

void func() {
    int id = 0;
    blah(id, id, id);
}
//!ClassAsArgument
//@A.cpp
struct Type {};
void func() {
    Type myType;
    blah(myType);
}
//=
struct Type {};
void blah(Type & myType)
{
}

void func() {
    Type myType;
    blah(myType);
}
//!TwiceSameClassAsArgument
//@A.cpp
struct Type {};
void func() {
    Type myType;
    blah(myType, myType);
}
//=
struct Type {};
void blah(Type & myType, Type & myType1)
{
}

void func() {
    Type myType;
    blah(myType, myType);
}
//!NestedFunctionWithParameter
//@A.cpp
void exists(int x) {}
void foo() {
    exists(func(42));
}
//=
void exists(int x) {}
void func(const int & i)
{
}

void foo() {
    exists(func(42));
}
//!ReplaceFunctionNameMacro
//@A.cpp
#define MACRO exists
void exists(int x) {}
void foo() {
    MACRO(func(42));
}
//=
#define MACRO exists
void exists(int x) {}
void func(const int & i)
{
}

void foo() {
    MACRO(func(42));
}
//!ReplaceFunctionMacro
//@A.cpp
#define MACRO(code) exists(code)
void exists(int x) {}
void foo() {
    MACRO(func(42));
}
//=
#define MACRO(code) exists(code)
void exists(int x) {}
void func(const int & i)
{
}

void foo() {
    MACRO(func(42));
}
//!CuteAssertEqualFunctionParameter
//@A.cpp
namespace cute {
template <typename ExpectedValue, typename ActualValue>
	void assert_equal(ExpectedValue const &expected
		,ActualValue const &actual ,char const *msg
		,char const *file ,int line) {
}}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))
void test(){
    ASSERT_EQUAL(42, function(42));
}
//=
namespace cute {
template <typename ExpectedValue, typename ActualValue>
	void assert_equal(ExpectedValue const &expected
		,ActualValue const &actual ,char const *msg
		,char const *file ,int line) {
}}
#define ASSERT_EQUALM(msg,expected,actual) cute::assert_equal((expected),(actual),msg,__FILE__,__LINE__)
#define ASSERT_EQUAL(expected,actual) ASSERT_EQUALM(#expected " == " #actual, (expected),(actual))
int function(const int & i)
{
    return int();
}

void test(){
    ASSERT_EQUAL(42, function(42));
}
//!TestNotyetDefinedVariables
//@A.cpp
void test()
{
    func(2, 3, 2.3, var);
}
//=
void func(const int & i, const int & j, const double & d, const int & var)
{
}

void test()
{
    func(2, 3, 2.3, var);
}
