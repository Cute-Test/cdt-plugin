//!TestDetectMarker
//@A.cpp
void func() {
    A a1;
}
//=
struct A {
};

void func() {
    A a1;
}
//!TestBug232
//@A.cpp
namespace N {
void test() {
	Klass k;
}
}
//=
namespace N {

struct Klass {
};
void test() {
	Klass k;
}
}
//!TestCallDefaultContructor
//@A.cpp
void test() {
    B b();
}
//=
struct B {
};

void test() {
    B b();
}
//!CreateTypeOutOfATemplatedFunction
//@A.cpp
template <typename T>
T testy(T t) {
	Klasse k;
}
//=
struct Klasse {
};

template <typename T>
T testy(T t) {
	Klasse k;
}
//!CreateTypeOutOfAMultiTemplatedFunction
//@A.cpp
template <typename U>
template <typename T>
T testy(T t) {
	Klasse k;
}
//=
struct Klasse {
};
template <typename U>
template <typename T>
T testy(T t) {
	Klasse k;
}
//!CreateTypeOutOfAMemberFunction
//@A.cpp
struct Test {
    void testy() {
        Klasse k;
    }
};
//=
struct Test {
	struct Klasse {
	};
    void testy() {
        Klasse k;
    }
};
//!CreateTypeOutOfATemplatedMemberFunction
//@A.cpp
struct Test {
	template <typename T>
    T testy(T t) {
        Klasse k;
        return T();
    }
};
//=
struct Test {
	struct Klasse {
	};
	template <typename T>
    T testy(T t) {
        Klasse k;
        return T();
    }
};
//!CreateTypeOutOfATemplatedMemberFunctionInsideATemplatedClass
//@A.cpp
template <typename C>
struct Test {
	template <typename T>
    T testy(T t) {
        Klasse k;
        return T();
    }
};
//=
template <typename C>
struct Test {
	struct Klasse {
	};
	template <typename T>
    T testy(T t) {
        Klasse k;
        return T();
    }
};
//!CreateTypeFromInheritance
//@A.cpp
struct A : B
{
};

void test() {
}
//=
struct B {
};
struct A : B
{
};

void test() {
}
//!CreateTemplatedType
//@A.cpp
void test() {
    B<int, double> b;
}
//=
template<typename T, typename U> struct B {
};

void test() {
    B<int, double> b;
}
//!CreateTemplatedGradType
//@A.cpp
struct A : B<int> {
};
void test() {
    A a;
}
//=
template<typename T> struct B {
};
struct A : B<int> {
};
void test() {
    A a;
}
//!CreateInTotallyEmptyFile
//@A.cpp
Type t;
//=
struct Type {
};
Type t;
//!CreateClassWithNamespaceAccess
//@A.cpp
void test() {
    X::foo();
}
//=
struct X {
};

void test() {
    X::foo();
}
//!CreateFirstOfMultipleNamespace
//@A.cpp
void test() {
    X::Y::foo();
}
//=
struct X {
};

void test() {
    X::Y::foo();
}
//!CreateSecondOfMultipleNamespace
//@A.cpp
struct X {
};
void test() {
    X::Y::foo();
}
//=
struct X {
	struct Y {
	};
};
void test() {
    X::Y::foo();
}
//!ClassInNamespace
//@A.cpp
namespace X {
}
void test() {
    X::A::foo();
}
//=
namespace X {
struct A {
};
}
void test() {
    X::A::foo();
}
//!Class in Namespace from Declaration
//@A.cpp
namespace X {
}

void test() {
    X::Inner xi;
}
//=
namespace X {
struct Inner {
};
}

void test() {
    X::Inner xi;
}
