//!ShouldFixVoidFunctionMacro
//@main.cpp
#define MACRO(X) do { X; } while (0);

//=
template<typename T1> 
inline void MACRO(T1&& X)
{
    do{
        X;
    } while (0);
}

//!ShouldFixAutoFunctionMacro
//@main.cpp
#define SQUARE(X) (X) * (X)

//=
template<typename T1> 
inline constexpr auto SQUARE(T1&& X) -> decltype((X) * (X))
{
    return ((X) * (X));
}

//!ShouldTransformMacrosInInactiveCode
//@main.cpp
#ifdef X
#define MACRO(A) (A)
#endif

//=
#ifdef X
template<typename T1> 
inline constexpr auto MACRO(T1&& A) -> decltype((A))
{
    return ((A));
}
#endif

//!ShouldTransformMultilineFunctionStyleMacros
//@main.cpp
#define VEC_COPY_4(b,a)				\
{						\
	(b)[0] = (a)[0];				\
	(b)[1] = (a)[1];				\
	(b)[2] = (a)[2];				\
	(b)[3] = (a)[3];				\
}\

//=
template<typename T1, typename T2> 
inline void VEC_COPY_4(T1&& b, T2&& a)
{
    {
        (b)[0] = (a)[0];
        (b)[1] = (a)[1];
        (b)[2] = (a)[2];
        (b)[3] = (a)[3];
    }
}

//!ShouldTransformMacrosThatToPointerArithmetic
//@main.cpp
#define __HI(x) *(int*)&x

//=
template<typename T1> 
inline constexpr auto __HI(T1&& x) -> decltype(*(int*)(&x))
{
    return (*(int*)(&x));
}

//!ShouldTransformMacrosThatToPointerArithmetic2
//@main.cpp
#define __HIp(x) *(int*)x

//=
template<typename T1> 
inline constexpr auto __HIp(T1&& x) -> decltype(*(int*)(x))
{
    return (*(int*)(x));
}

//!ShouldTransformThisMacro
//@main.cpp
#define CERES_ALIGN_OF(T) __alignof(T)

//=
template<typename T1> 
inline constexpr auto CERES_ALIGN_OF(T1&& T) -> decltype(alignof ((T)))
{
    return (alignof ((T)));
}

